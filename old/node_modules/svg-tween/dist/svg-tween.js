(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["SVGTween"] = factory();
	else
		root["SVGTween"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.tweenPaths = undefined;

	var _tween = __webpack_require__(1);

	var _tween2 = _interopRequireDefault(_tween);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.tweenPaths = _tween.tweenPaths;
	exports.default = _tween2.default;

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.tweenPaths = undefined;

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	var _tweening = __webpack_require__(2);

	var _tweening2 = _interopRequireDefault(_tweening);

	var _svgPoints = __webpack_require__(9);

	var _match = __webpack_require__(12);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var tweenPaths = function tweenPaths(_ref) {
	  var complete = _ref.complete,
	      duration = _ref.duration,
	      easing = _ref.easing,
	      from = _ref.from,
	      next = _ref.next,
	      to = _ref.to;

	  var f = Array.isArray(from) ? from.map(function (d) {
	    return { type: 'path', d: d };
	  }) : { type: 'path', d: from };

	  var t = Array.isArray(to) ? to.map(function (d) {
	    return { type: 'path', d: d };
	  }) : { type: 'path', d: to };

	  tween({ complete: complete, duration: duration, easing: easing, from: f, next: next, to: t });
	};

	var tween = function tween(_ref2) {
	  var _complete = _ref2.complete,
	      duration = _ref2.duration,
	      easing = _ref2.easing,
	      from = _ref2.from,
	      _ref2$middleware = _ref2.middleware,
	      middleware = _ref2$middleware === undefined ? [] : _ref2$middleware,
	      _next = _ref2.next,
	      to = _ref2.to;

	  var fs = Array.isArray(from) ? from : [from];
	  var ts = Array.isArray(to) ? to : [to];

	  var fp = fs.map(_svgPoints.toPoints);
	  var tp = ts.map(_svgPoints.toPoints);

	  var _matchPointArrays = (0, _match.matchPointArrays)(fp, tp),
	      _matchPointArrays2 = _slicedToArray(_matchPointArrays, 2),
	      f = _matchPointArrays2[0],
	      t = _matchPointArrays2[1];

	  (0, _tweening2.default)({
	    complete: function complete() {
	      if (typeof _next === 'function') {
	        tp.forEach(function (p, i) {
	          return _next((0, _svgPoints.toPath)(p), i);
	        });
	      }

	      if (typeof _complete === 'function') {
	        _complete();
	      }
	    },
	    duration: duration,
	    easing: easing,
	    from: f,
	    middleware: middleware,
	    next: function next(points) {
	      if (typeof _next === 'function') {
	        points.forEach(function (p, i) {
	          return _next((0, _svgPoints.toPath)(p), i);
	        });
	      }
	    },
	    to: t
	  });
	};

	exports.tweenPaths = tweenPaths;
	exports.default = tween;

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _tween = __webpack_require__(3);

	var _tween2 = _interopRequireDefault(_tween);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _tween2.default;

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _easingFuncFromName = __webpack_require__(4);

	var _easingFuncFromName2 = _interopRequireDefault(_easingFuncFromName);

	var _tweenGenerator = __webpack_require__(6);

	var _tweenGenerator2 = _interopRequireDefault(_tweenGenerator);

	var _middleware = __webpack_require__(8);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var tween = function tween(_ref) {
	  var _ref$duration = _ref.duration;
	  var duration = _ref$duration === undefined ? 200 : _ref$duration;
	  var complete = _ref.complete;
	  var _ref$easing = _ref.easing;
	  var easing = _ref$easing === undefined ? 'easeInOutQuad' : _ref$easing;
	  var from = _ref.from;
	  var _ref$middleware = _ref.middleware;
	  var middleware = _ref$middleware === undefined ? [] : _ref$middleware;
	  var next = _ref.next;
	  var to = _ref.to;

	  if (typeof duration !== 'number' || duration <= 0 || duration == Infinity) {
	    throw new Error('Duration must be a positive number less than infinity');
	  }

	  var easingFunc = typeof easing === 'function' ? easing : (0, _easingFuncFromName2.default)(easing);

	  var g = (0, _tweenGenerator2.default)({
	    duration: duration,
	    easing: easingFunc,
	    from: middleware.length ? (0, _middleware.middlewareIn)(from, middleware) : from,
	    to: middleware.length ? (0, _middleware.middlewareIn)(to, middleware) : to
	  });

	  var animate = function animate() {
	    var _g$next = g.next();

	    var done = _g$next.done;
	    var value = _g$next.value;


	    var v = middleware.length ? (0, _middleware.middlewareOut)(value, middleware) : value;

	    if (done) {
	      if (typeof next === 'function') {
	        next(to);
	      }

	      if (typeof complete === 'function') {
	        complete();
	      }
	    } else {
	      if (typeof next === 'function') {
	        next(v);
	      }

	      window.requestAnimationFrame(animate);
	    }
	  };

	  window.requestAnimationFrame(animate);
	};

	exports.default = tween;

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _tweenFunctions = __webpack_require__(5);

	var _tweenFunctions2 = _interopRequireDefault(_tweenFunctions);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var easingFuncFromName = function easingFuncFromName(name) {
	  var func = _tweenFunctions2.default[name];

	  if (typeof func !== 'function') {
	    throw new Error('Easing function ' + name + ' does not exist');
	  }

	  return func;
	};

	exports.default = easingFuncFromName;

/***/ },
/* 5 */
/***/ function(module, exports) {

	'use strict';

	// t: current time, b: beginning value, _c: final value, d: total duration
	var tweenFunctions = {
	  linear: function(t, b, _c, d) {
	    var c = _c - b;
	    return c * t / d + b;
	  },
	  easeInQuad: function(t, b, _c, d) {
	    var c = _c - b;
	    return c * (t /= d) * t + b;
	  },
	  easeOutQuad: function(t, b, _c, d) {
	    var c = _c - b;
	    return -c * (t /= d) * (t - 2) + b;
	  },
	  easeInOutQuad: function(t, b, _c, d) {
	    var c = _c - b;
	    if ((t /= d / 2) < 1) {
	      return c / 2 * t * t + b;
	    } else {
	      return -c / 2 * ((--t) * (t - 2) - 1) + b;
	    }
	  },
	  easeInCubic: function(t, b, _c, d) {
	    var c = _c - b;
	    return c * (t /= d) * t * t + b;
	  },
	  easeOutCubic: function(t, b, _c, d) {
	    var c = _c - b;
	    return c * ((t = t / d - 1) * t * t + 1) + b;
	  },
	  easeInOutCubic: function(t, b, _c, d) {
	    var c = _c - b;
	    if ((t /= d / 2) < 1) {
	      return c / 2 * t * t * t + b;
	    } else {
	      return c / 2 * ((t -= 2) * t * t + 2) + b;
	    }
	  },
	  easeInQuart: function(t, b, _c, d) {
	    var c = _c - b;
	    return c * (t /= d) * t * t * t + b;
	  },
	  easeOutQuart: function(t, b, _c, d) {
	    var c = _c - b;
	    return -c * ((t = t / d - 1) * t * t * t - 1) + b;
	  },
	  easeInOutQuart: function(t, b, _c, d) {
	    var c = _c - b;
	    if ((t /= d / 2) < 1) {
	      return c / 2 * t * t * t * t + b;
	    } else {
	      return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
	    }
	  },
	  easeInQuint: function(t, b, _c, d) {
	    var c = _c - b;
	    return c * (t /= d) * t * t * t * t + b;
	  },
	  easeOutQuint: function(t, b, _c, d) {
	    var c = _c - b;
	    return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
	  },
	  easeInOutQuint: function(t, b, _c, d) {
	    var c = _c - b;
	    if ((t /= d / 2) < 1) {
	      return c / 2 * t * t * t * t * t + b;
	    } else {
	      return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
	    }
	  },
	  easeInSine: function(t, b, _c, d) {
	    var c = _c - b;
	    return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
	  },
	  easeOutSine: function(t, b, _c, d) {
	    var c = _c - b;
	    return c * Math.sin(t / d * (Math.PI / 2)) + b;
	  },
	  easeInOutSine: function(t, b, _c, d) {
	    var c = _c - b;
	    return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
	  },
	  easeInExpo: function(t, b, _c, d) {
	    var c = _c - b;
	    return (t==0) ? b : c * Math.pow(2, 10 * (t/d - 1)) + b;
	  },
	  easeOutExpo: function(t, b, _c, d) {
	    var c = _c - b;
	    return (t==d) ? b+c : c * (-Math.pow(2, -10 * t/d) + 1) + b;
	  },
	  easeInOutExpo: function(t, b, _c, d) {
	    var c = _c - b;
	    if (t === 0) {
	      return b;
	    }
	    if (t === d) {
	      return b + c;
	    }
	    if ((t /= d / 2) < 1) {
	      return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
	    } else {
	      return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;
	    }
	  },
	  easeInCirc: function(t, b, _c, d) {
	    var c = _c - b;
	    return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
	  },
	  easeOutCirc: function(t, b, _c, d) {
	    var c = _c - b;
	    return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
	  },
	  easeInOutCirc: function(t, b, _c, d) {
	    var c = _c - b;
	    if ((t /= d / 2) < 1) {
	      return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
	    } else {
	      return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
	    }
	  },
	  easeInElastic: function(t, b, _c, d) {
	    var c = _c - b;
	    var a, p, s;
	    s = 1.70158;
	    p = 0;
	    a = c;
	    if (t === 0) {
	      return b;
	    } else if ((t /= d) === 1) {
	      return b + c;
	    }
	    if (!p) {
	      p = d * 0.3;
	    }
	    if (a < Math.abs(c)) {
	      a = c;
	      s = p / 4;
	    } else {
	      s = p / (2 * Math.PI) * Math.asin(c / a);
	    }
	    return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
	  },
	  easeOutElastic: function(t, b, _c, d) {
	    var c = _c - b;
	    var a, p, s;
	    s = 1.70158;
	    p = 0;
	    a = c;
	    if (t === 0) {
	      return b;
	    } else if ((t /= d) === 1) {
	      return b + c;
	    }
	    if (!p) {
	      p = d * 0.3;
	    }
	    if (a < Math.abs(c)) {
	      a = c;
	      s = p / 4;
	    } else {
	      s = p / (2 * Math.PI) * Math.asin(c / a);
	    }
	    return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b;
	  },
	  easeInOutElastic: function(t, b, _c, d) {
	    var c = _c - b;
	    var a, p, s;
	    s = 1.70158;
	    p = 0;
	    a = c;
	    if (t === 0) {
	      return b;
	    } else if ((t /= d / 2) === 2) {
	      return b + c;
	    }
	    if (!p) {
	      p = d * (0.3 * 1.5);
	    }
	    if (a < Math.abs(c)) {
	      a = c;
	      s = p / 4;
	    } else {
	      s = p / (2 * Math.PI) * Math.asin(c / a);
	    }
	    if (t < 1) {
	      return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
	    } else {
	      return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * 0.5 + c + b;
	    }
	  },
	  easeInBack: function(t, b, _c, d, s) {
	    var c = _c - b;
	    if (s === void 0) {
	      s = 1.70158;
	    }
	    return c * (t /= d) * t * ((s + 1) * t - s) + b;
	  },
	  easeOutBack: function(t, b, _c, d, s) {
	    var c = _c - b;
	    if (s === void 0) {
	      s = 1.70158;
	    }
	    return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
	  },
	  easeInOutBack: function(t, b, _c, d, s) {
	    var c = _c - b;
	    if (s === void 0) {
	      s = 1.70158;
	    }
	    if ((t /= d / 2) < 1) {
	      return c / 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b;
	    } else {
	      return c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;
	    }
	  },
	  easeInBounce: function(t, b, _c, d) {
	    var c = _c - b;
	    var v;
	    v = tweenFunctions.easeOutBounce(d - t, 0, c, d);
	    return c - v + b;
	  },
	  easeOutBounce: function(t, b, _c, d) {
	    var c = _c - b;
	    if ((t /= d) < 1 / 2.75) {
	      return c * (7.5625 * t * t) + b;
	    } else if (t < 2 / 2.75) {
	      return c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b;
	    } else if (t < 2.5 / 2.75) {
	      return c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b;
	    } else {
	      return c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;
	    }
	  },
	  easeInOutBounce: function(t, b, _c, d) {
	    var c = _c - b;
	    var v;
	    if (t < d / 2) {
	      v = tweenFunctions.easeInBounce(t * 2, 0, c, d);
	      return v * 0.5 + b;
	    } else {
	      v = tweenFunctions.easeOutBounce(t * 2 - d, 0, c, d);
	      return v * 0.5 + c * 0.5 + b;
	    }
	  }
	};

	module.exports = tweenFunctions;


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _match = __webpack_require__(7);

	var _match2 = _interopRequireDefault(_match);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var tweenGenerator = regeneratorRuntime.mark(function tweenGenerator(_ref) {
	  var _this = this;

	  var duration = _ref.duration;
	  var easing = _ref.easing;
	  var from = _ref.from;
	  var to = _ref.to;

	  var start, _loop;

	  return regeneratorRuntime.wrap(function tweenGenerator$(_context2) {
	    while (1) {
	      switch (_context2.prev = _context2.next) {
	        case 0:
	          start = Date.now();
	          _loop = regeneratorRuntime.mark(function _loop() {
	            var time;
	            return regeneratorRuntime.wrap(function _loop$(_context) {
	              while (1) {
	                switch (_context.prev = _context.next) {
	                  case 0:
	                    time = Date.now() - start;
	                    _context.next = 3;
	                    return (0, _match2.default)(from, to, function (a, b) {
	                      return easing.call(null, time, a, b, duration);
	                    });

	                  case 3:
	                  case 'end':
	                    return _context.stop();
	                }
	              }
	            }, _loop, _this);
	          });

	        case 2:
	          if (!(Date.now() - start < duration)) {
	            _context2.next = 6;
	            break;
	          }

	          return _context2.delegateYield(_loop(), 't0', 4);

	        case 4:
	          _context2.next = 2;
	          break;

	        case 6:
	        case 'end':
	          return _context2.stop();
	      }
	    }
	  }, tweenGenerator, this);
	});

	exports.default = tweenGenerator;

/***/ },
/* 7 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var match = function match(a, b, func) {
	  if (Array.isArray(a) && Array.isArray(b)) {
	    var result = [];

	    for (var i = 0, l = a.length; i < l; i++) {
	      result.push(match(a[i], b[i], func));
	    }

	    return result;
	  } else if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === 'object' && (typeof b === 'undefined' ? 'undefined' : _typeof(b)) === 'object' && a !== null && b !== null) {
	    var _result = {};

	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;

	    try {
	      for (var _iterator = Object.keys(a)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var k = _step.value;

	        _result[k] = match(a[k], b[k], func);
	      }
	    } catch (err) {
	      _didIteratorError = true;
	      _iteratorError = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion && _iterator.return) {
	          _iterator.return();
	        }
	      } finally {
	        if (_didIteratorError) {
	          throw _iteratorError;
	        }
	      }
	    }

	    return _result;
	  } else if (typeof a === 'number' && typeof b === 'number') {
	    return func(a, b);
	  }

	  return a;
	};

	exports.default = match;

/***/ },
/* 8 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var middlewareIn = function middlewareIn(value, middleware) {
	  if (Array.isArray(value)) {
	    var result = [];

	    for (var i = 0, l = value.length; i < l; i++) {
	      result.push(middlewareIn(value[i], middleware));
	    }

	    return result;
	  } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value !== null) {
	    var _result = {};

	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;

	    try {
	      for (var _iterator = Object.keys(value)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var k = _step.value;

	        _result[k] = middlewareIn(value[k], middleware);
	      }
	    } catch (err) {
	      _didIteratorError = true;
	      _iteratorError = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion && _iterator.return) {
	          _iterator.return();
	        }
	      } finally {
	        if (_didIteratorError) {
	          throw _iteratorError;
	        }
	      }
	    }

	    return _result;
	  } else if (typeof value === 'number' || typeof value === 'string') {
	    return middleware.reduce(function (v, _ref) {
	      var i = _ref.i;
	      return i(v);
	    }, value);
	  }

	  return value;
	};

	var middlewareOut = function middlewareOut(value, middleware) {
	  if (Array.isArray(value)) {
	    var result = [];

	    for (var i = 0, l = value.length; i < l; i++) {
	      result.push(middlewareOut(value[i], middleware));
	    }

	    return result;
	  } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value !== null) {
	    if (value.middleware) {
	      return middleware.filter(function (_ref2) {
	        var name = _ref2.name;
	        return name === value.middleware;
	      }).reduce(function (v, _ref3) {
	        var o = _ref3.o;
	        return o(v);
	      }, value);
	    } else {
	      var _result2 = {};

	      var _iteratorNormalCompletion2 = true;
	      var _didIteratorError2 = false;
	      var _iteratorError2 = undefined;

	      try {
	        for (var _iterator2 = Object.keys(value)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	          var k = _step2.value;

	          _result2[k] = middlewareOut(value[k], middleware);
	        }
	      } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion2 && _iterator2.return) {
	            _iterator2.return();
	          }
	        } finally {
	          if (_didIteratorError2) {
	            throw _iteratorError2;
	          }
	        }
	      }

	      return _result2;
	    }
	  }

	  return value;
	};

	exports.middlewareIn = middlewareIn;
	exports.middlewareOut = middlewareOut;

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.toPoints = exports.toPath = undefined;

	var _toPath = __webpack_require__(10);

	var _toPath2 = _interopRequireDefault(_toPath);

	var _toPoints = __webpack_require__(11);

	var _toPoints2 = _interopRequireDefault(_toPoints);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.toPath = _toPath2.default;
	exports.toPoints = _toPoints2.default;

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _toPoints = __webpack_require__(11);

	var _toPoints2 = _interopRequireDefault(_toPoints);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var pointsToD = function (p) {
	  var d = '';
	  var i = 0;
	  var firstPoint = void 0;

	  for (var _iterator = p, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	    var _ref;

	    if (_isArray) {
	      if (_i >= _iterator.length) break;
	      _ref = _iterator[_i++];
	    } else {
	      _i = _iterator.next();
	      if (_i.done) break;
	      _ref = _i.value;
	    }

	    var point = _ref;
	    var _point$curve = point.curve,
	        curve = _point$curve === undefined ? false : _point$curve,
	        moveTo = point.moveTo,
	        x = point.x,
	        y = point.y;

	    var isFirstPoint = i === 0 || moveTo;
	    var isLastPoint = i === p.length - 1 || p[i + 1].moveTo;
	    var prevPoint = i === 0 ? null : p[i - 1];

	    if (isFirstPoint) {
	      firstPoint = point;

	      if (!isLastPoint) {
	        d += 'M' + x + ',' + y;
	      }
	    } else if (curve) {
	      switch (curve.type) {
	        case 'arc':
	          var _point$curve2 = point.curve,
	              _point$curve2$largeAr = _point$curve2.largeArcFlag,
	              largeArcFlag = _point$curve2$largeAr === undefined ? 0 : _point$curve2$largeAr,
	              rx = _point$curve2.rx,
	              ry = _point$curve2.ry,
	              _point$curve2$sweepFl = _point$curve2.sweepFlag,
	              sweepFlag = _point$curve2$sweepFl === undefined ? 0 : _point$curve2$sweepFl,
	              _point$curve2$xAxisRo = _point$curve2.xAxisRotation,
	              xAxisRotation = _point$curve2$xAxisRo === undefined ? 0 : _point$curve2$xAxisRo;

	          d += 'A' + rx + ',' + ry + ',' + xAxisRotation + ',' + largeArcFlag + ',' + sweepFlag + ',' + x + ',' + y;
	          break;
	        case 'cubic':
	          var _point$curve3 = point.curve,
	              cx1 = _point$curve3.x1,
	              cy1 = _point$curve3.y1,
	              cx2 = _point$curve3.x2,
	              cy2 = _point$curve3.y2;

	          d += 'C' + cx1 + ',' + cy1 + ',' + cx2 + ',' + cy2 + ',' + x + ',' + y;
	          break;
	        case 'quadratic':
	          var _point$curve4 = point.curve,
	              qx1 = _point$curve4.x1,
	              qy1 = _point$curve4.y1;

	          d += 'Q' + qx1 + ',' + qy1 + ',' + x + ',' + y;
	          break;
	      }

	      if (isLastPoint && x === firstPoint.x && y === firstPoint.y) {
	        d += 'Z';
	      }
	    } else if (isLastPoint && x === firstPoint.x && y === firstPoint.y) {
	      d += 'Z';
	    } else if (x !== prevPoint.x && y !== prevPoint.y) {
	      d += 'L' + x + ',' + y;
	    } else if (x !== prevPoint.x) {
	      d += 'H' + x;
	    } else if (y !== prevPoint.y) {
	      d += 'V' + y;
	    }

	    i++;
	  }

	  return d;
	};

	var toPath = function (s) {
	  var isPoints = Array.isArray(s);
	  var isGroup = isPoints ? Array.isArray(s[0]) : s.type === 'g';
	  var points = isPoints ? s : isGroup ? s.shapes.map(function (shp) {
	    return (0, _toPoints2.default)(shp);
	  }) : (0, _toPoints2.default)(s);

	  if (isGroup) {
	    return points.map(function (p) {
	      return pointsToD(p);
	    });
	  }

	  return pointsToD(points);
	};

	exports.default = toPath;

/***/ },
/* 11 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

	var toPoints = function (_ref) {
	  var type = _ref.type,
	      attributes = _objectWithoutProperties(_ref, ['type']);

	  switch (type) {
	    case 'circle':
	      return getPointsFromCircle(attributes);
	    case 'ellipse':
	      return getPointsFromEllipse(attributes);
	    case 'line':
	      return getPointsFromLine(attributes);
	    case 'path':
	      return getPointsFromPath(attributes);
	    case 'polygon':
	      return getPointsFromPolygon(attributes);
	    case 'polyline':
	      return getPointsFromPolyline(attributes);
	    case 'rect':
	      return getPointsFromRect(attributes);
	    case 'g':
	      return getPointsFromG(attributes);
	    default:
	      throw new Error('Not a valid shape type');
	  }
	};

	var getPointsFromCircle = function (_ref2) {
	  var cx = _ref2.cx,
	      cy = _ref2.cy,
	      r = _ref2.r;

	  return [{ x: cx, y: cy - r, moveTo: true }, { x: cx, y: cy + r, curve: { type: 'arc', rx: r, ry: r, sweepFlag: 1 } }, { x: cx, y: cy - r, curve: { type: 'arc', rx: r, ry: r, sweepFlag: 1 } }];
	};

	var getPointsFromEllipse = function (_ref3) {
	  var cx = _ref3.cx,
	      cy = _ref3.cy,
	      rx = _ref3.rx,
	      ry = _ref3.ry;

	  return [{ x: cx, y: cy - ry, moveTo: true }, { x: cx, y: cy + ry, curve: { type: 'arc', rx: rx, ry: ry, sweepFlag: 1 } }, { x: cx, y: cy - ry, curve: { type: 'arc', rx: rx, ry: ry, sweepFlag: 1 } }];
	};

	var getPointsFromLine = function (_ref4) {
	  var x1 = _ref4.x1,
	      x2 = _ref4.x2,
	      y1 = _ref4.y1,
	      y2 = _ref4.y2;

	  return [{ x: x1, y: y1, moveTo: true }, { x: x2, y: y2 }];
	};

	var validCommands = /[MmLlHhVvCcSsQqTtAaZz]/g;

	var commandLengths = {
	  A: 7,
	  C: 6,
	  H: 1,
	  L: 2,
	  M: 2,
	  Q: 4,
	  S: 4,
	  T: 2,
	  V: 1,
	  Z: 0
	};

	var relativeCommands = ['a', 'c', 'h', 'l', 'm', 'q', 's', 't', 'v'];

	var isRelative = function (command) {
	  return relativeCommands.indexOf(command) !== -1;
	};

	var optionalArcKeys = ['xAxisRotation', 'largeArcFlag', 'sweepFlag'];

	var getCommands = function (d) {
	  return d.match(validCommands);
	};

	var getParams = function (d) {
	  return d.split(validCommands).map(function (v) {
	    return v.replace(/[0-9]+-/g, function (m) {
	      return m.slice(0, -1) + ' -';
	    });
	  }).map(function (v) {
	    return v.replace(/\.[0-9]+/g, function (m) {
	      return m + ' ';
	    });
	  }).map(function (v) {
	    return v.trim();
	  }).filter(function (v) {
	    return v.length > 0;
	  }).map(function (v) {
	    return v.split(/[ ,]+/).map(parseFloat).filter(function (n) {
	      return !isNaN(n);
	    });
	  });
	};

	var getPointsFromPath = function (_ref5) {
	  var d = _ref5.d;

	  var commands = getCommands(d);
	  var params = getParams(d);

	  var points = [];

	  var moveTo = void 0;

	  for (var i = 0, l = commands.length; i < l; i++) {
	    var command = commands[i];
	    var upperCaseCommand = command.toUpperCase();
	    var commandLength = commandLengths[upperCaseCommand];
	    var relative = isRelative(command);

	    if (commandLength > 0) {
	      var commandParams = params.shift();
	      var iterations = commandParams.length / commandLength;

	      for (var j = 0; j < iterations; j++) {
	        var prevPoint = i === 0 ? null : points[points.length - 1];

	        switch (upperCaseCommand) {
	          case 'M':
	            var x = (relative && prevPoint ? prevPoint.x : 0) + commandParams.shift();
	            var y = (relative && prevPoint ? prevPoint.y : 0) + commandParams.shift();

	            moveTo = { x: x, y: y };

	            points.push({ x: x, y: y, moveTo: true });

	            break;

	          case 'L':
	            points.push({
	              x: (relative ? prevPoint.x : 0) + commandParams.shift(),
	              y: (relative ? prevPoint.y : 0) + commandParams.shift()
	            });

	            break;

	          case 'H':
	            points.push({
	              x: (relative ? prevPoint.x : 0) + commandParams.shift(),
	              y: prevPoint.y
	            });

	            break;

	          case 'V':
	            points.push({
	              x: prevPoint.x,
	              y: (relative ? prevPoint.y : 0) + commandParams.shift()
	            });

	            break;

	          case 'A':
	            points.push({
	              curve: {
	                type: 'arc',
	                rx: commandParams.shift(),
	                ry: commandParams.shift(),
	                xAxisRotation: commandParams.shift(),
	                largeArcFlag: commandParams.shift(),
	                sweepFlag: commandParams.shift()
	              },
	              x: (relative ? prevPoint.x : 0) + commandParams.shift(),
	              y: (relative ? prevPoint.y : 0) + commandParams.shift()
	            });

	            for (var _iterator = optionalArcKeys, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	              var _ref6;

	              if (_isArray) {
	                if (_i >= _iterator.length) break;
	                _ref6 = _iterator[_i++];
	              } else {
	                _i = _iterator.next();
	                if (_i.done) break;
	                _ref6 = _i.value;
	              }

	              var k = _ref6;

	              if (points[points.length - 1]['curve'][k] === 0) {
	                delete points[points.length - 1]['curve'][k];
	              }
	            }

	            break;

	          case 'C':
	            points.push({
	              curve: {
	                type: 'cubic',
	                x1: (relative ? prevPoint.x : 0) + commandParams.shift(),
	                y1: (relative ? prevPoint.y : 0) + commandParams.shift(),
	                x2: (relative ? prevPoint.x : 0) + commandParams.shift(),
	                y2: (relative ? prevPoint.y : 0) + commandParams.shift()
	              },
	              x: (relative ? prevPoint.x : 0) + commandParams.shift(),
	              y: (relative ? prevPoint.y : 0) + commandParams.shift()
	            });

	            break;

	          case 'S':
	            var sx2 = (relative ? prevPoint.x : 0) + commandParams.shift();
	            var sy2 = (relative ? prevPoint.y : 0) + commandParams.shift();
	            var sx = (relative ? prevPoint.x : 0) + commandParams.shift();
	            var sy = (relative ? prevPoint.y : 0) + commandParams.shift();

	            var diff = {};

	            var sx1 = void 0;
	            var sy1 = void 0;

	            if (prevPoint.curve && prevPoint.curve.type === 'cubic') {
	              diff.x = Math.abs(prevPoint.x - prevPoint.curve.x2);
	              diff.y = Math.abs(prevPoint.y - prevPoint.curve.y2);
	              sx1 = prevPoint.x < prevPoint.curve.x2 ? prevPoint.x - diff.x : prevPoint.x + diff.x;
	              sy1 = prevPoint.y < prevPoint.curve.y2 ? prevPoint.y - diff.y : prevPoint.y + diff.y;
	            } else {
	              diff.x = Math.abs(sx - sx2);
	              diff.y = Math.abs(sy - sy2);
	              sx1 = prevPoint.x;
	              sy1 = prevPoint.y;
	            }

	            points.push({ curve: { type: 'cubic', x1: sx1, y1: sy1, x2: sx2, y2: sy2 }, x: sx, y: sy });

	            break;

	          case 'Q':
	            points.push({
	              curve: {
	                type: 'quadratic',
	                x1: (relative ? prevPoint.x : 0) + commandParams.shift(),
	                y1: (relative ? prevPoint.y : 0) + commandParams.shift()
	              },
	              x: (relative ? prevPoint.x : 0) + commandParams.shift(),
	              y: (relative ? prevPoint.y : 0) + commandParams.shift()
	            });

	            break;

	          case 'T':
	            var tx = (relative ? prevPoint.x : 0) + commandParams.shift();
	            var ty = (relative ? prevPoint.y : 0) + commandParams.shift();

	            var tx1 = void 0;
	            var ty1 = void 0;

	            if (prevPoint.curve && prevPoint.curve.type === 'quadratic') {
	              var _diff = {
	                x: Math.abs(prevPoint.x - prevPoint.curve.x1),
	                y: Math.abs(prevPoint.y - prevPoint.curve.y1)
	              };

	              tx1 = prevPoint.x < prevPoint.curve.x1 ? prevPoint.x - _diff.x : prevPoint.x + _diff.x;
	              ty1 = prevPoint.y < prevPoint.curve.y1 ? prevPoint.y - _diff.y : prevPoint.y + _diff.y;
	            } else {
	              tx1 = prevPoint.x;
	              ty1 = prevPoint.y;
	            }

	            points.push({ curve: { type: 'quadratic', x1: tx1, y1: ty1 }, x: tx, y: ty });

	            break;
	        }
	      }
	    } else {
	      points.push({ x: moveTo.x, y: moveTo.y });
	    }
	  }

	  return points;
	};

	var getPointsFromPolygon = function (_ref7) {
	  var points = _ref7.points;

	  return getPointsFromPoints({ closed: true, points: points });
	};

	var getPointsFromPolyline = function (_ref8) {
	  var points = _ref8.points;

	  return getPointsFromPoints({ closed: false, points: points });
	};

	var getPointsFromPoints = function (_ref9) {
	  var closed = _ref9.closed,
	      points = _ref9.points;

	  var numbers = points.split(/[\s,]+/).map(function (n) {
	    return parseFloat(n);
	  });

	  var p = numbers.reduce(function (arr, point, i) {
	    if (i % 2 === 0) {
	      arr.push({ x: point });
	    } else {
	      arr[(i - 1) / 2].y = point;
	    }

	    return arr;
	  }, []);

	  if (closed) {
	    p.push(_extends({}, p[0]));
	  }

	  p[0].moveTo = true;

	  return p;
	};

	var getPointsFromRect = function (_ref10) {
	  var height = _ref10.height,
	      rx = _ref10.rx,
	      ry = _ref10.ry,
	      width = _ref10.width,
	      x = _ref10.x,
	      y = _ref10.y;

	  if (rx || ry) {
	    return getPointsFromRectWithCornerRadius({
	      height: height,
	      rx: rx || ry,
	      ry: ry || rx,
	      width: width,
	      x: x,
	      y: y
	    });
	  }

	  return getPointsFromBasicRect({ height: height, width: width, x: x, y: y });
	};

	var getPointsFromBasicRect = function (_ref11) {
	  var height = _ref11.height,
	      width = _ref11.width,
	      x = _ref11.x,
	      y = _ref11.y;

	  return [{ x: x, y: y, moveTo: true }, { x: x + width, y: y }, { x: x + width, y: y + height }, { x: x, y: y + height }, { x: x, y: y }];
	};

	var getPointsFromRectWithCornerRadius = function (_ref12) {
	  var height = _ref12.height,
	      rx = _ref12.rx,
	      ry = _ref12.ry,
	      width = _ref12.width,
	      x = _ref12.x,
	      y = _ref12.y;

	  var curve = { type: 'arc', rx: rx, ry: ry, sweepFlag: 1 };

	  return [{ x: x + rx, y: y, moveTo: true }, { x: x + width - rx, y: y }, { x: x + width, y: y + ry, curve: curve }, { x: x + width, y: y + height - ry }, { x: x + width - rx, y: y + height, curve: curve }, { x: x + rx, y: y + height }, { x: x, y: y + height - ry, curve: curve }, { x: x, y: y + ry }, { x: x + rx, y: y, curve: curve }];
	};

	var getPointsFromG = function (_ref13) {
	  var shapes = _ref13.shapes;
	  return shapes.map(function (s) {
	    return toPoints(s);
	  });
	};

	exports.default = toPoints;

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.matchPointArrays = exports.matchPoints = undefined;

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _points = __webpack_require__(13);

	var matchCurves = function matchCurves(a, b) {
	  var c = [];
	  var d = [];

	  for (var i = 0, l = a.length; i < l; i++) {
	    if (a[i].curve && !b[i].curve) {
	      c.push(a[i]);
	      d.push(_extends({}, b[i], {
	        curve: {
	          type: 'cubic',
	          x1: b[i - 1].x,
	          y1: b[i - 1].y,
	          x2: b[i].x,
	          y2: b[i].y
	        }
	      }));
	    } else if (b[i].curve && !a[i].curve) {
	      d.push(b[i]);
	      c.push(_extends({}, a[i], {
	        curve: {
	          type: 'cubic',
	          x1: a[i - 1].x,
	          y1: a[i - 1].y,
	          x2: a[i].x,
	          y2: a[i].y
	        }
	      }));
	    } else {
	      c.push(a[i]);
	      d.push(b[i]);
	    }
	  }

	  return [c, d];
	};

	var matchPoints = function matchPoints(a, b) {
	  var c = (0, _points.cubify)((0, _points.remove)(a));
	  var d = (0, _points.cubify)((0, _points.remove)(b));

	  if (d.length > c.length) {
	    c = (0, _points.add)(c, d.length);
	  } else if (c.length > d.length) {
	    d = (0, _points.add)(d, c.length);
	  }

	  return matchCurves(c, d);
	};

	var matchPointArrays = function matchPointArrays(a, b) {
	  var x = [];
	  var y = [];

	  for (var i = 0, l = a.length; i < l; i++) {
	    var _matchPoints = matchPoints(a[i], b[i]),
	        _matchPoints2 = _slicedToArray(_matchPoints, 2),
	        c = _matchPoints2[0],
	        d = _matchPoints2[1];

	    x.push(c);
	    y.push(d);
	  }

	  return [x, y];
	};

	exports.matchPoints = matchPoints;
	exports.matchPointArrays = matchPointArrays;

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.scale = exports.rotate = exports.reverse = exports.remove = exports.position = exports.offset = exports.moveIndex = exports.length = exports.cubify = exports.boundingBox = exports.add = undefined;

	var _add = __webpack_require__(14);

	var _add2 = _interopRequireDefault(_add);

	var _boundingBox = __webpack_require__(18);

	var _boundingBox2 = _interopRequireDefault(_boundingBox);

	var _cubify = __webpack_require__(15);

	var _cubify2 = _interopRequireDefault(_cubify);

	var _length = __webpack_require__(20);

	var _length2 = _interopRequireDefault(_length);

	var _moveIndex = __webpack_require__(21);

	var _moveIndex2 = _interopRequireDefault(_moveIndex);

	var _offset = __webpack_require__(22);

	var _offset2 = _interopRequireDefault(_offset);

	var _position = __webpack_require__(23);

	var _position2 = _interopRequireDefault(_position);

	var _remove = __webpack_require__(24);

	var _remove2 = _interopRequireDefault(_remove);

	var _reverse = __webpack_require__(25);

	var _reverse2 = _interopRequireDefault(_reverse);

	var _rotate = __webpack_require__(26);

	var _rotate2 = _interopRequireDefault(_rotate);

	var _scale = __webpack_require__(27);

	var _scale2 = _interopRequireDefault(_scale);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.add = _add2.default;
	exports.boundingBox = _boundingBox2.default;
	exports.cubify = _cubify2.default;
	exports.length = _length2.default;
	exports.moveIndex = _moveIndex2.default;
	exports.offset = _offset2.default;
	exports.position = _position2.default;
	exports.remove = _remove2.default;
	exports.reverse = _reverse2.default;
	exports.rotate = _rotate2.default;
	exports.scale = _scale2.default;

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.curvePoints = undefined;

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	var _cubify = __webpack_require__(15);

	var _cubify2 = _interopRequireDefault(_cubify);

	var _helpers = __webpack_require__(17);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	var basicPoints = function basicPoints(a, b) {
	  return [{
	    x: (0, _helpers.numberAtInterval)(a.x, b.x, 0.5),
	    y: (0, _helpers.numberAtInterval)(a.y, b.y, 0.5)
	  }, b];
	};

	var curvePoints = function curvePoints(a, b) {
	  var _b$curve = b.curve,
	      x1 = _b$curve.x1,
	      y1 = _b$curve.y1,
	      x2 = _b$curve.x2,
	      y2 = _b$curve.y2;


	  var A = { x: a.x, y: a.y };
	  var B = { x: x1, y: y1 };
	  var C = { x: x2, y: y2 };
	  var D = { x: b.x, y: b.y };
	  var E = { x: (0, _helpers.numberAtInterval)(A.x, B.x, 0.5), y: (0, _helpers.numberAtInterval)(A.y, B.y, 0.5) };
	  var F = { x: (0, _helpers.numberAtInterval)(B.x, C.x, 0.5), y: (0, _helpers.numberAtInterval)(B.y, C.y, 0.5) };
	  var G = { x: (0, _helpers.numberAtInterval)(C.x, D.x, 0.5), y: (0, _helpers.numberAtInterval)(C.y, D.y, 0.5) };
	  var H = { x: (0, _helpers.numberAtInterval)(E.x, F.x, 0.5), y: (0, _helpers.numberAtInterval)(E.y, F.y, 0.5) };
	  var J = { x: (0, _helpers.numberAtInterval)(F.x, G.x, 0.5), y: (0, _helpers.numberAtInterval)(F.y, G.y, 0.5) };
	  var K = { x: (0, _helpers.numberAtInterval)(H.x, J.x, 0.5), y: (0, _helpers.numberAtInterval)(H.y, J.y, 0.5) };

	  return [{ x: K.x, y: K.y, curve: { type: 'cubic', x1: E.x, y1: E.y, x2: H.x, y2: H.y } }, { x: D.x, y: D.y, curve: { type: 'cubic', x1: J.x, y1: J.y, x2: G.x, y2: G.y } }];
	};

	var points = function points(a, b) {
	  return b.curve ? curvePoints(a, b) : basicPoints(a, b);
	};

	var addPoints = function addPoints(shape, pointsRequired) {
	  var s = [].concat(_toConsumableArray(shape));

	  for (var i = 1; i < s.length; i += 2) {
	    if (s.length >= pointsRequired) {
	      return s;
	    }

	    var _points = points(s[i - 1], s[i]),
	        _points2 = _slicedToArray(_points, 2),
	        a = _points2[0],
	        b = _points2[1];

	    s.splice(i, 1, a, b);
	  }

	  return addPoints(s, pointsRequired);
	};

	var add = function add(shape, pointsRequired) {
	  return addPoints((0, _cubify2.default)(shape), pointsRequired);
	};

	exports.curvePoints = curvePoints;
	exports.default = add;

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _arcToBezier = __webpack_require__(16);

	var _arcToBezier2 = _interopRequireDefault(_arcToBezier);

	var _helpers = __webpack_require__(17);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var cubifyShape = function cubifyShape(shape) {
	  var s = [];

	  for (var i = 0, l = shape.length; i < l; i++) {
	    var point = shape[i];

	    if (point.curve && point.curve.type !== 'cubic') {
	      var _shape = shape[i - 1],
	          px = _shape.x,
	          py = _shape.y;
	      var cx = point.x,
	          cy = point.y;


	      if (point.curve.type === 'arc') {
	        var curves = (0, _arcToBezier2.default)({
	          px: px,
	          py: py,
	          cx: cx,
	          cy: cy,
	          rx: point.curve.rx,
	          ry: point.curve.ry,
	          xAxisRotation: point.curve.xAxisRotation,
	          largeArcFlag: point.curve.largeArcFlag,
	          sweepFlag: point.curve.sweepFlag
	        });

	        curves.forEach(function (_ref) {
	          var x1 = _ref.x1,
	              y1 = _ref.y1,
	              x2 = _ref.x2,
	              y2 = _ref.y2,
	              x = _ref.x,
	              y = _ref.y;

	          s.push({ x: x, y: y, curve: { type: 'cubic', x1: x1, y1: y1, x2: x2, y2: y2 } });
	        });
	      } else if (point.curve.type === 'quadratic') {
	        var x1 = px + 2 / 3 * (point.curve.x1 - px);
	        var y1 = py + 2 / 3 * (point.curve.y1 - py);
	        var x2 = cx + 2 / 3 * (point.curve.x1 - cx);
	        var y2 = cy + 2 / 3 * (point.curve.y1 - cy);

	        s.push({ x: cx, y: cy, curve: { type: 'cubic', x1: x1, y1: y1, x2: x2, y2: y2 } });
	      }
	    } else {
	      s.push(point);
	    }
	  }

	  return s;
	};

	var cubify = function cubify(s) {
	  return (0, _helpers.applyFuncToShapes)(cubifyShape, s);
	};

	exports.default = cubify;

/***/ },
/* 16 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	// I extracted this from the a2c function from
	// SVG path – https://github.com/fontello/svgpath
	//
	// All credit goes to:
	//
	// Sergey Batishchev – https://github.com/snb2013
	// Vitaly Puzrin – https://github.com/puzrin
	// Alex Kocharin – https://github.com/rlidwka

	var TAU = Math.PI * 2;

	var mapToEllipse = function mapToEllipse(_ref, rx, ry, cosphi, sinphi, centerx, centery) {
	  var x = _ref.x,
	      y = _ref.y;

	  x *= rx;
	  y *= ry;

	  var xp = cosphi * x - sinphi * y;
	  var yp = sinphi * x + cosphi * y;

	  return {
	    x: xp + centerx,
	    y: yp + centery
	  };
	};

	var approxUnitArc = function approxUnitArc(ang1, ang2) {
	  var a = 4 / 3 * Math.tan(ang2 / 4);

	  var x1 = Math.cos(ang1);
	  var y1 = Math.sin(ang1);
	  var x2 = Math.cos(ang1 + ang2);
	  var y2 = Math.sin(ang1 + ang2);

	  return [{
	    x: x1 - y1 * a,
	    y: y1 + x1 * a
	  }, {
	    x: x2 + y2 * a,
	    y: y2 - x2 * a
	  }, {
	    x: x2,
	    y: y2
	  }];
	};

	var vectorAngle = function vectorAngle(ux, uy, vx, vy) {
	  var sign = ux * vy - uy * vx < 0 ? -1 : 1;
	  var umag = Math.sqrt(ux * ux + uy * uy);
	  var vmag = Math.sqrt(ux * ux + uy * uy);
	  var dot = ux * vx + uy * vy;

	  var div = dot / (umag * vmag);

	  if (div > 1) {
	    div = 1;
	  }

	  if (div < -1) {
	    div = -1;
	  }

	  return sign * Math.acos(div);
	};

	var getArcCenter = function getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {
	  var rxsq = Math.pow(rx, 2);
	  var rysq = Math.pow(ry, 2);
	  var pxpsq = Math.pow(pxp, 2);
	  var pypsq = Math.pow(pyp, 2);

	  var radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;

	  if (radicant < 0) {
	    radicant = 0;
	  }

	  radicant /= rxsq * pypsq + rysq * pxpsq;
	  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);

	  var centerxp = radicant * rx / ry * pyp;
	  var centeryp = radicant * -ry / rx * pxp;

	  var centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2;
	  var centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2;

	  var vx1 = (pxp - centerxp) / rx;
	  var vy1 = (pyp - centeryp) / ry;
	  var vx2 = (-pxp - centerxp) / rx;
	  var vy2 = (-pyp - centeryp) / ry;

	  var ang1 = vectorAngle(1, 0, vx1, vy1);
	  var ang2 = vectorAngle(vx1, vy1, vx2, vy2);

	  if (sweepFlag === 0 && ang2 > 0) {
	    ang2 -= TAU;
	  }

	  if (sweepFlag === 1 && ang2 < 0) {
	    ang2 += TAU;
	  }

	  return [centerx, centery, ang1, ang2];
	};

	var arcToBezier = function arcToBezier(_ref2) {
	  var px = _ref2.px,
	      py = _ref2.py,
	      cx = _ref2.cx,
	      cy = _ref2.cy,
	      rx = _ref2.rx,
	      ry = _ref2.ry,
	      _ref2$xAxisRotation = _ref2.xAxisRotation,
	      xAxisRotation = _ref2$xAxisRotation === undefined ? 0 : _ref2$xAxisRotation,
	      _ref2$largeArcFlag = _ref2.largeArcFlag,
	      largeArcFlag = _ref2$largeArcFlag === undefined ? 0 : _ref2$largeArcFlag,
	      _ref2$sweepFlag = _ref2.sweepFlag,
	      sweepFlag = _ref2$sweepFlag === undefined ? 0 : _ref2$sweepFlag;

	  var curves = [];

	  if (rx === 0 || ry === 0) {
	    return [];
	  }

	  var sinphi = Math.sin(xAxisRotation * TAU / 360);
	  var cosphi = Math.cos(xAxisRotation * TAU / 360);

	  var pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2;
	  var pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2;

	  if (pxp === 0 && pyp === 0) {
	    return [];
	  }

	  rx = Math.abs(rx);
	  ry = Math.abs(ry);

	  var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);

	  if (lambda > 1) {
	    rx *= Math.sqrt(lambda);
	    ry *= Math.sqrt(lambda);
	  }

	  var _getArcCenter = getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp),
	      _getArcCenter2 = _slicedToArray(_getArcCenter, 4),
	      centerx = _getArcCenter2[0],
	      centery = _getArcCenter2[1],
	      ang1 = _getArcCenter2[2],
	      ang2 = _getArcCenter2[3];

	  var segments = Math.max(Math.ceil(Math.abs(ang2) / (TAU / 4)), 1);

	  ang2 /= segments;

	  for (var i = 0; i < segments; i++) {
	    curves.push(approxUnitArc(ang1, ang2));
	    ang1 += ang2;
	  }

	  return curves.map(function (curve) {
	    var _mapToEllipse = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery),
	        x1 = _mapToEllipse.x,
	        y1 = _mapToEllipse.y;

	    var _mapToEllipse2 = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery),
	        x2 = _mapToEllipse2.x,
	        y2 = _mapToEllipse2.y;

	    var _mapToEllipse3 = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery),
	        x = _mapToEllipse3.x,
	        y = _mapToEllipse3.y;

	    return { x1: x1, y1: y1, x2: x2, y2: y2, x: x, y: y };
	  });
	};

	exports.default = arcToBezier;

/***/ },
/* 17 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var angleFromSides = function angleFromSides(a, b, c) {
	  var r = Math.acos((Math.pow(a, 2) + Math.pow(b, 2) - Math.pow(c, 2)) / (2 * a * b));

	  return r * (180 / Math.PI);
	};

	var applyFuncToShapes = function applyFuncToShapes(f, s) {
	  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	    args[_key - 2] = arguments[_key];
	  }

	  if (isShapeArray(s)) {
	    return s.map(function (shape) {
	      return f.apply(undefined, [shape].concat(args));
	    });
	  }

	  return f.apply(undefined, [s].concat(args));
	};

	var getShapeArray = function getShapeArray(s) {
	  return isShapeArray(s) ? s : [s];
	};

	var isShapeArray = function isShapeArray(s) {
	  return Array.isArray(s[0]);
	};

	var numberAtInterval = function numberAtInterval(a, b, interval) {
	  var c = a === b ? 0 : Math.abs(b - a);
	  return c === 0 ? a : a < b ? a + c * interval : a - c * interval;
	};

	exports.angleFromSides = angleFromSides;
	exports.applyFuncToShapes = applyFuncToShapes;
	exports.getShapeArray = getShapeArray;
	exports.isShapeArray = isShapeArray;
	exports.numberAtInterval = numberAtInterval;

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _decurve = __webpack_require__(19);

	var _decurve2 = _interopRequireDefault(_decurve);

	var _helpers = __webpack_require__(17);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var boundingBox = function boundingBox(s) {
	  var bottom = void 0;
	  var left = void 0;
	  var right = void 0;
	  var top = void 0;

	  var shapes = (0, _helpers.getShapeArray)(s);

	  shapes.map(function (shape) {
	    return (0, _decurve2.default)(shape).map(function (_ref) {
	      var x = _ref.x,
	          y = _ref.y;

	      if (typeof bottom !== 'number' || y > bottom) {
	        bottom = y;
	      }

	      if (typeof left !== 'number' || x < left) {
	        left = x;
	      }

	      if (typeof right !== 'number' || x > right) {
	        right = x;
	      }

	      if (typeof top !== 'number' || y < top) {
	        top = y;
	      }
	    });
	  });

	  return {
	    bottom: bottom,
	    center: {
	      x: left + (right - left) / 2,
	      y: top + (bottom - top) / 2
	    },
	    left: left,
	    right: right,
	    top: top
	  };
	};

	exports.default = boundingBox;

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	var _helpers = __webpack_require__(17);

	var _cubify = __webpack_require__(15);

	var _cubify2 = _interopRequireDefault(_cubify);

	var _add = __webpack_require__(14);

	var _length = __webpack_require__(20);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	var angle = function angle(triangle) {
	  var _triangle$ = _slicedToArray(triangle[0], 2),
	      ax = _triangle$[0],
	      ay = _triangle$[1];

	  var _triangle$2 = _slicedToArray(triangle[1], 2),
	      bx = _triangle$2[0],
	      by = _triangle$2[1];

	  var _triangle$3 = _slicedToArray(triangle[2], 2),
	      cx = _triangle$3[0],
	      cy = _triangle$3[1];

	  var a = (0, _length.linearLength)(ax, ay, bx, by);
	  var b = (0, _length.linearLength)(bx, by, cx, cy);
	  var c = (0, _length.linearLength)(cx, cy, ax, ay);

	  return (0, _helpers.angleFromSides)(a, b, c);
	};

	var curved = function curved(shape) {
	  return shape.reduce(function (c, _ref) {
	    var curve = _ref.curve;
	    return curve ? true : c;
	  }, false);
	};

	var decurve = function decurve(shape) {
	  var accuracy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

	  if (!curved(shape)) {
	    return shape;
	  }

	  var s = (0, _cubify2.default)(shape);
	  var d = [];

	  s.map(function (point, i) {
	    if (point.curve) {
	      var prevPoint = s[i - 1];
	      straighten(prevPoint, point, accuracy).map(function (p) {
	        return d.push(p);
	      });
	    } else {
	      d.push(point);
	    }
	  });

	  return d;
	};

	var straight = function straight(x1, y1, cx1, cy1, x2, y2, cx2, cy2, accuracy) {
	  var t1 = [[cx1, cy1], [x2, y2], [x1, y1]];
	  var t2 = [[cx2, cy2], [x1, y1], [x2, y2]];
	  return angle(t1) < accuracy && angle(t2) < accuracy;
	};

	var straighten = function straighten(prevPoint, point, accuracy) {
	  var x1 = prevPoint.x,
	      y1 = prevPoint.y;
	  var x2 = point.x,
	      y2 = point.y,
	      curve = point.curve;
	  var cx1 = curve.x1,
	      cy1 = curve.y1,
	      cx2 = curve.x2,
	      cy2 = curve.y2;


	  if (straight(x1, y1, cx1, cy1, x2, y2, cx2, cy2, accuracy)) {
	    return [point];
	  }

	  var _curvePoints = (0, _add.curvePoints)(prevPoint, point),
	      _curvePoints2 = _slicedToArray(_curvePoints, 2),
	      midPoint = _curvePoints2[0],
	      lastPoint = _curvePoints2[1];

	  return [].concat(_toConsumableArray(straighten(prevPoint, midPoint, accuracy)), _toConsumableArray(straighten(midPoint, lastPoint, accuracy)));
	};

	exports.default = decurve;

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.linearLength = undefined;

	var _decurve = __webpack_require__(19);

	var _decurve2 = _interopRequireDefault(_decurve);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var length = function length(shape, accuracy) {
	  var s = (0, _decurve2.default)(shape, accuracy);

	  return s.reduce(function (currentLength, _ref, i) {
	    var x2 = _ref.x,
	        y2 = _ref.y,
	        moveTo = _ref.moveTo;

	    if (!moveTo) {
	      var _s = s[i - 1],
	          x1 = _s.x,
	          y1 = _s.y;

	      currentLength += linearLength(x1, y1, x2, y2);
	    }

	    return currentLength;
	  }, 0);
	};

	var linearLength = function linearLength(x1, y1, x2, y2) {
	  return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
	};

	exports.linearLength = linearLength;
	exports.default = length;

/***/ },
/* 21 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	var countLinePoints = function countLinePoints(lines) {
	  return lines.reduce(function (count, points) {
	    return count + countPoints(points);
	  }, 0);
	};

	var countPoints = function countPoints(points) {
	  return points.length - (isJoined(points) ? 1 : 0);
	};

	var isJoined = function isJoined(points) {
	  var firstPoint = points[0];
	  var lastPoint = points[points.length - 1];
	  return firstPoint.x === lastPoint.x && firstPoint.y === lastPoint.y;
	};

	var joinLines = function joinLines(lines) {
	  return lines.reduce(function (shape, line) {
	    return [].concat(_toConsumableArray(shape), _toConsumableArray(line));
	  }, []);
	};

	var moveIndex = function moveIndex(shape, offset) {
	  var lines = splitLines(shape);
	  var count = countLinePoints(lines);
	  var normalisedOffset = (offset % count + count) % count;

	  if (!normalisedOffset) {
	    return shape;
	  }

	  var _nextIndex = nextIndex(lines, normalisedOffset),
	      lineIndex = _nextIndex.lineIndex,
	      pointIndex = _nextIndex.pointIndex;

	  var reorderedLines = reorderLines(lines, lineIndex);
	  var firstLine = reorderPoints(reorderedLines[0], pointIndex);
	  var restOfLines = [].concat(_toConsumableArray(reorderedLines)).splice(1);

	  return joinLines([firstLine].concat(_toConsumableArray(restOfLines)));
	};

	var nextIndex = function nextIndex(lines, offset) {
	  for (var i = 0, l = lines.length; i < l; i++) {
	    var count = countPoints(lines[i]);

	    if (offset <= count - 1) {
	      return {
	        lineIndex: i,
	        pointIndex: offset
	      };
	    }

	    offset -= count;
	  }
	};

	var reorderLines = function reorderLines(lines, offset) {
	  return [].concat(_toConsumableArray(lines)).splice(offset).concat([].concat(_toConsumableArray(lines)).splice(0, offset));
	};

	var reorderPoints = function reorderPoints(points, offset) {
	  if (!offset) {
	    return points;
	  }

	  var nextPoints = [{ x: points[offset].x, y: points[offset].y, moveTo: true }].concat(_toConsumableArray([].concat(_toConsumableArray(points)).splice(offset + 1)));

	  if (isJoined(points)) {
	    return [].concat(_toConsumableArray(nextPoints), _toConsumableArray([].concat(_toConsumableArray(points)).splice(1, offset)));
	  }

	  return [].concat(_toConsumableArray(nextPoints), _toConsumableArray([].concat(_toConsumableArray(points)).splice(0, offset + 1)));
	};

	var splitLines = function splitLines(shape) {
	  return shape.reduce(function (lines, point) {
	    if (point.moveTo) {
	      lines.push([]);
	    }

	    lines[lines.length - 1].push(point);

	    return lines;
	  }, []);
	};

	exports.default = moveIndex;

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _helpers = __webpack_require__(17);

	var offsetPoints = function offsetPoints(shape, x, y) {
	  return shape.map(function (point) {
	    var p = _extends({}, point);

	    p.x += x;
	    p.y += y;

	    if (p.curve) {
	      p.curve = _extends({}, p.curve);

	      if (p.curve.type === 'quadratic' || p.curve.type === 'cubic') {
	        p.curve.x1 += x;
	        p.curve.y1 += y;
	      }

	      if (p.curve.type === 'cubic') {
	        p.curve.x2 += x;
	        p.curve.y2 += y;
	      }
	    }

	    return p;
	  });
	};

	var offset = function offset(s) {
	  var x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	  var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	  return (0, _helpers.applyFuncToShapes)(offsetPoints, s, x, y);
	};

	exports.default = offset;

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _decurve = __webpack_require__(19);

	var _decurve2 = _interopRequireDefault(_decurve);

	var _length = __webpack_require__(20);

	var _length2 = _interopRequireDefault(_length);

	var _helpers = __webpack_require__(17);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var angle = function angle(x1, y1, x2, y2, a) {
	  if (x1 === x2) {
	    return y1 >= y2 ? 0 : 180;
	  }

	  var b = 100;
	  var c = (0, _length.linearLength)(x2, y2, x1, y1 - b);
	  var ang = (0, _helpers.angleFromSides)(a, b, c);

	  return x1 < x2 ? ang : 360 - ang;
	};

	var over = function over(shape, length, totalLength, desiredLength) {
	  var _shape = shape[length - 2],
	      x1 = _shape.x,
	      y1 = _shape.y;
	  var _shape2 = shape[length - 1],
	      x2 = _shape2.x,
	      y2 = _shape2.y;

	  var segmentLength = (0, _length.linearLength)(x1, y1, x2, y2);
	  var segmentInterval = (desiredLength - totalLength) / segmentLength + 1;
	  return { x1: x1, y1: y1, x2: x2, y2: y2, segmentInterval: segmentInterval, segmentLength: segmentLength };
	};

	var position = function position(shape, interval, accuracy) {
	  var s = (0, _decurve2.default)(shape, accuracy);
	  var l = s.length;
	  var t = (0, _length2.default)(s);
	  var d = t * interval;

	  var _ref = interval > 1 ? over(s, l, t, d) : interval < 0 ? under(s, d) : within(s, l, d),
	      x1 = _ref.x1,
	      y1 = _ref.y1,
	      x2 = _ref.x2,
	      y2 = _ref.y2,
	      segmentInterval = _ref.segmentInterval,
	      segmentLength = _ref.segmentLength;

	  return {
	    angle: angle(x1, y1, x2, y2, segmentLength),
	    x: (0, _helpers.numberAtInterval)(x1, x2, segmentInterval),
	    y: (0, _helpers.numberAtInterval)(y1, y2, segmentInterval)
	  };
	};

	var under = function under(shape, desiredLength) {
	  var _shape$ = shape[0],
	      x1 = _shape$.x,
	      y1 = _shape$.y;
	  var _shape$2 = shape[1],
	      x2 = _shape$2.x,
	      y2 = _shape$2.y;

	  var segmentLength = (0, _length.linearLength)(x1, y1, x2, y2);
	  var segmentInterval = desiredLength / segmentLength;
	  return { x1: x1, y1: y1, x2: x2, y2: y2, segmentInterval: segmentInterval, segmentLength: segmentLength };
	};

	var within = function within(shape, length, desiredLength) {
	  var currentLength = 0;

	  for (var i = 0; i < length; i++) {
	    var moveTo = shape[i].moveTo;


	    if (!moveTo) {
	      var _shape3 = shape[i - 1],
	          x1 = _shape3.x,
	          y1 = _shape3.y;
	      var _shape$i = shape[i],
	          x2 = _shape$i.x,
	          y2 = _shape$i.y;


	      var segmentLength = (0, _length.linearLength)(x1, y1, x2, y2);

	      if (currentLength + segmentLength >= desiredLength) {
	        var segmentInterval = (desiredLength - currentLength) / segmentLength;
	        return { x1: x1, y1: y1, x2: x2, y2: y2, segmentInterval: segmentInterval, segmentLength: segmentLength };
	      }

	      currentLength += segmentLength;
	    }
	  }
	};

	exports.default = position;

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _helpers = __webpack_require__(17);

	var isBetween = function isBetween(a, b, c) {
	  if (b.curve || c.curve) {
	    return false;
	  }

	  var crossProduct = (c.y - a.y) * (b.x - a.x) - (c.x - a.x) * (b.y - a.y);

	  if (Math.abs(crossProduct) > Number.EPSILON) {
	    return false;
	  }

	  var dotProduct = (c.x - a.x) * (b.x - a.x) + (c.y - a.y) * (b.y - a.y);

	  if (dotProduct < 0) {
	    return false;
	  }

	  var squaredLengthBA = (b.x - a.x) * (b.x - a.x) + (b.y - a.y) * (b.y - a.y);

	  if (dotProduct > squaredLengthBA) {
	    return false;
	  }

	  return true;
	};

	var removePoints = function removePoints(shape) {
	  var s = [];

	  for (var i = 0, l = shape.length; i < l; i++) {
	    var a = s[s.length - 1];
	    var b = shape[i + 1];
	    var c = shape[i];

	    if (!(a && b && c) || !isBetween(a, b, c)) {
	      s.push(c);
	    }
	  }

	  return s;
	};

	var remove = function remove(s) {
	  return (0, _helpers.applyFuncToShapes)(removePoints, s);
	};

	exports.default = remove;

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _cubify = __webpack_require__(15);

	var _cubify2 = _interopRequireDefault(_cubify);

	var _helpers = __webpack_require__(17);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var reversePoints = function reversePoints(shape) {
	  var m = void 0;
	  var c = void 0;

	  return shape.reverse().map(function (_ref, i) {
	    var x = _ref.x,
	        y = _ref.y,
	        moveTo = _ref.moveTo,
	        curve = _ref.curve;

	    var point = { x: x, y: y };

	    if (c) {
	      var _c = c,
	          x2 = _c.x1,
	          y2 = _c.y1,
	          x1 = _c.x2,
	          y1 = _c.y2;

	      point.curve = { type: 'cubic', x1: x1, y1: y1, x2: x2, y2: y2 };
	    }

	    if (i === 0 || m) {
	      point.moveTo = true;
	    }

	    m = moveTo;
	    c = curve || null;

	    return point;
	  });
	};

	var reverse = function reverse(s) {
	  return (0, _helpers.applyFuncToShapes)(reversePoints, (0, _cubify2.default)(s));
	};

	exports.default = reverse;

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	var _helpers = __webpack_require__(17);

	var _boundingBox2 = __webpack_require__(18);

	var _boundingBox3 = _interopRequireDefault(_boundingBox2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var rotatePoint = function rotatePoint(x, y, c, s, about) {
	  var offsetX = about.x,
	      offsetY = about.y;

	  var relativeX = x - offsetX;
	  var relativeY = y - offsetY;

	  return [relativeX * c - relativeY * s + offsetX, relativeX * s + relativeY * c + offsetY];
	};

	var rotatePoints = function rotatePoints(shape, angle, about) {
	  return shape.map(function (point) {
	    var r = angle * Math.PI / 180;
	    var c = Math.cos(r);
	    var s = Math.sin(r);

	    var _rotatePoint = rotatePoint(point.x, point.y, c, s, about),
	        _rotatePoint2 = _slicedToArray(_rotatePoint, 2),
	        x = _rotatePoint2[0],
	        y = _rotatePoint2[1];

	    var p = _extends({}, point, { x: x, y: y });

	    if (p.curve) {
	      if (p.curve.type === 'quadratic' || p.curve.type === 'cubic') {
	        var _rotatePoint3 = rotatePoint(p.curve.x1, p.curve.y1, c, s, about),
	            _rotatePoint4 = _slicedToArray(_rotatePoint3, 2),
	            x1 = _rotatePoint4[0],
	            y1 = _rotatePoint4[1];

	        p.curve = _extends({}, p.curve, { x1: x1, y1: y1 });
	      }

	      if (p.curve.type === 'cubic') {
	        var _rotatePoint5 = rotatePoint(p.curve.x2, p.curve.y2, c, s, about),
	            _rotatePoint6 = _slicedToArray(_rotatePoint5, 2),
	            x2 = _rotatePoint6[0],
	            y2 = _rotatePoint6[1];

	        p.curve = _extends({}, p.curve, { x2: x2, y2: y2 });
	      }
	    }

	    return p;
	  });
	};

	var rotate = function rotate(s, angle) {
	  var _boundingBox = (0, _boundingBox3.default)(s),
	      about = _boundingBox.center;

	  return (0, _helpers.applyFuncToShapes)(rotatePoints, s, angle, about);
	};

	exports.default = rotate;

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _boundingBox2 = __webpack_require__(18);

	var _boundingBox3 = _interopRequireDefault(_boundingBox2);

	var _helpers = __webpack_require__(17);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var scalePoint = function scalePoint(point, scaleFactor, anchorX, anchorY) {
	  var p = _extends({}, point);

	  p.x = anchorX - (anchorX - p.x) * scaleFactor;
	  p.y = anchorY - (anchorY - p.y) * scaleFactor;

	  if (point.curve) {
	    p.curve = _extends({}, p.curve);

	    if (p.curve.type === 'arc') {
	      if (p.curve.rx) {
	        p.curve.rx = p.curve.rx * scaleFactor;
	      }

	      if (p.curve.ry) {
	        p.curve.ry = p.curve.ry * scaleFactor;
	      }
	    } else {
	      p.curve.x1 = anchorX - (anchorX - p.curve.x1) * scaleFactor;
	      p.curve.y1 = anchorY - (anchorY - p.curve.y1) * scaleFactor;

	      if (p.curve.type === 'cubic') {
	        p.curve.x2 = anchorX - (anchorX - p.curve.x2) * scaleFactor;
	        p.curve.y2 = anchorY - (anchorY - p.curve.y2) * scaleFactor;
	      }
	    }
	  }

	  return p;
	};

	var scale = function scale(s, scaleFactor) {
	  var anchor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'center';

	  var _boundingBox = (0, _boundingBox3.default)(s),
	      bottom = _boundingBox.bottom,
	      center = _boundingBox.center,
	      left = _boundingBox.left,
	      right = _boundingBox.right,
	      top = _boundingBox.top;

	  var anchorX = center.x;
	  var anchorY = center.y;

	  switch (anchor) {
	    case 'topLeft':
	      anchorX = left;
	      anchorY = top;
	      break;
	    case 'topRight':
	      anchorX = right;
	      anchorY = top;
	      break;
	    case 'bottomRight':
	      anchorX = right;
	      anchorY = bottom;
	      break;
	    case 'bottomLeft':
	      anchorX = left;
	      anchorY = bottom;
	      break;
	  }

	  return (0, _helpers.applyFuncToShapes)(function (shape) {
	    return shape.map(function (point) {
	      return scalePoint(point, scaleFactor, anchorX, anchorY);
	    });
	  }, s);
	};

	exports.default = scale;

/***/ }
/******/ ])
});
;