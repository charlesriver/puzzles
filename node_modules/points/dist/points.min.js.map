{"version":3,"file":"points.min.js","sources":["../src/arcToBezier.js","../src/helpers.js","../src/cubify.js","../src/add.js","../src/length.js","../src/decurve.js","../src/boundingBox.js","../src/moveIndex.js","../src/offset.js","../src/position.js","../src/remove.js","../src/reverse.js","../src/rotate.js","../src/scale.js"],"sourcesContent":["// I extracted this from the a2c function from\n// SVG path – https://github.com/fontello/svgpath\n//\n// All credit goes to:\n//\n// Sergey Batishchev – https://github.com/snb2013\n// Vitaly Puzrin – https://github.com/puzrin\n// Alex Kocharin – https://github.com/rlidwka\n\nconst TAU = Math.PI * 2\n\nconst mapToEllipse = ({ x, y }, rx, ry, cosphi, sinphi, centerx, centery) => {\n  x *= rx\n  y *= ry\n\n  const xp = cosphi * x - sinphi * y\n  const yp = sinphi * x + cosphi * y\n\n  return {\n    x: xp + centerx,\n    y: yp + centery\n  }\n}\n\nconst approxUnitArc = (ang1, ang2) => {\n  const a = 4 / 3 * Math.tan(ang2 / 4)\n\n  const x1 = Math.cos(ang1)\n  const y1 = Math.sin(ang1)\n  const x2 = Math.cos(ang1 + ang2)\n  const y2 = Math.sin(ang1 + ang2)\n\n  return [\n    {\n      x: x1 - y1 * a,\n      y: y1 + x1 * a\n    },\n    {\n      x: x2 + y2 * a,\n      y: y2 - x2 * a\n    },\n    {\n      x: x2,\n      y: y2\n    }\n  ]\n}\n\nconst vectorAngle = (ux, uy, vx, vy) => {\n  const sign = (ux * vy - uy * vx < 0) ? -1 : 1\n  const umag = Math.sqrt(ux * ux + uy * uy)\n  const vmag = Math.sqrt(ux * ux + uy * uy)\n  const dot = ux * vx + uy * vy\n\n  let div = dot / (umag * vmag)\n\n  if (div > 1) {\n    div = 1\n  }\n\n  if (div < -1) {\n    div = -1\n  }\n\n  return sign * Math.acos(div)\n}\n\nconst getArcCenter = (\n  px,\n  py,\n  cx,\n  cy,\n  rx,\n  ry,\n  largeArcFlag,\n  sweepFlag,\n  sinphi,\n  cosphi,\n  pxp,\n  pyp\n) => {\n  const rxsq = Math.pow(rx, 2)\n  const rysq = Math.pow(ry, 2)\n  const pxpsq = Math.pow(pxp, 2)\n  const pypsq = Math.pow(pyp, 2)\n\n  let radicant = (rxsq * rysq) - (rxsq * pypsq) - (rysq * pxpsq)\n\n  if (radicant < 0) {\n    radicant = 0\n  }\n\n  radicant /= (rxsq * pypsq) + (rysq * pxpsq)\n  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1)\n\n  const centerxp = radicant * rx / ry * pyp\n  const centeryp = radicant * -ry / rx * pxp\n\n  const centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2\n  const centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2\n\n  const vx1 = (pxp - centerxp) / rx\n  const vy1 = (pyp - centeryp) / ry\n  const vx2 = (-pxp - centerxp) / rx\n  const vy2 = (-pyp - centeryp) / ry\n\n  let ang1 = vectorAngle(1, 0, vx1, vy1)\n  let ang2 = vectorAngle(vx1, vy1, vx2, vy2)\n\n  if (sweepFlag === 0 && ang2 > 0) {\n    ang2 -= TAU\n  }\n\n  if (sweepFlag === 1 && ang2 < 0) {\n    ang2 += TAU\n  }\n\n  return [ centerx, centery, ang1, ang2 ]\n}\n\nconst arcToBezier = ({\n  px,\n  py,\n  cx,\n  cy,\n  rx,\n  ry,\n  xAxisRotation = 0,\n  largeArcFlag = 0,\n  sweepFlag = 0\n}) => {\n  const curves = []\n\n  if (rx === 0 || ry === 0) {\n    return []\n  }\n\n  const sinphi = Math.sin(xAxisRotation * TAU / 360)\n  const cosphi = Math.cos(xAxisRotation * TAU / 360)\n\n  const pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2\n  const pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2\n\n  if (pxp === 0 && pyp === 0) {\n    return []\n  }\n\n  rx = Math.abs(rx)\n  ry = Math.abs(ry)\n\n  const lambda =\n    Math.pow(pxp, 2) / Math.pow(rx, 2) +\n    Math.pow(pyp, 2) / Math.pow(ry, 2)\n\n  if (lambda > 1) {\n    rx *= Math.sqrt(lambda)\n    ry *= Math.sqrt(lambda)\n  }\n\n  let [ centerx, centery, ang1, ang2 ] = getArcCenter(\n    px,\n    py,\n    cx,\n    cy,\n    rx,\n    ry,\n    largeArcFlag,\n    sweepFlag,\n    sinphi,\n    cosphi,\n    pxp,\n    pyp\n  )\n\n  const segments = Math.max(Math.ceil(Math.abs(ang2) / (TAU / 4)), 1)\n\n  ang2 /= segments\n\n  for (let i = 0; i < segments; i++) {\n    curves.push(approxUnitArc(ang1, ang2))\n    ang1 += ang2\n  }\n\n  return curves.map(curve => {\n    const { x: x1, y: y1 } = mapToEllipse(curve[ 0 ], rx, ry, cosphi, sinphi, centerx, centery)\n    const { x: x2, y: y2 } = mapToEllipse(curve[ 1 ], rx, ry, cosphi, sinphi, centerx, centery)\n    const { x, y } = mapToEllipse(curve[ 2 ], rx, ry, cosphi, sinphi, centerx, centery)\n\n    return { x1, y1, x2, y2, x, y }\n  })\n}\n\nexport default arcToBezier\n","const angleFromSides = (a, b, c) => {\n  const r = Math.acos(\n    (Math.pow(a, 2) + Math.pow(b, 2) - Math.pow(c, 2)) /\n    (2 * a * b)\n  )\n\n  return r * (180 / Math.PI)\n}\n\nconst applyFuncToShapes = (f, s, ...args) => {\n  if (isShapeArray(s)) {\n    return s.map(shape => f(shape, ...args))\n  }\n\n  return f(s, ...args)\n}\n\nconst getShapeArray = s => isShapeArray(s) ? s : [ s ]\n\nconst isShapeArray = s => Array.isArray(s[ 0 ])\n\nconst numberAtInterval = (a, b, interval) => {\n  const c = a === b ? 0 : Math.abs(b - a)\n  return c === 0 ? a : (a < b ? a + c * interval : a - c * interval)\n}\n\nexport {\n  angleFromSides,\n  applyFuncToShapes,\n  getShapeArray,\n  isShapeArray,\n  numberAtInterval\n}\n","import arcToBezier from './arcToBezier'\nimport { applyFuncToShapes } from './helpers'\n\nconst cubifyShape = shape => {\n  const s = []\n\n  for (let i = 0, l = shape.length; i < l; i++) {\n    const point = shape[ i ]\n\n    if (point.curve && point.curve.type !== 'cubic') {\n      const { x: px, y: py } = shape[ i - 1 ]\n      const { x: cx, y: cy } = point\n\n      if (point.curve.type === 'arc') {\n        const curves = arcToBezier({\n          px,\n          py,\n          cx,\n          cy,\n          rx: point.curve.rx,\n          ry: point.curve.ry,\n          xAxisRotation: point.curve.xAxisRotation,\n          largeArcFlag: point.curve.largeArcFlag,\n          sweepFlag: point.curve.sweepFlag\n        })\n\n        curves.forEach(({ x1, y1, x2, y2, x, y }) => {\n          s.push({ x, y, curve: { type: 'cubic', x1, y1, x2, y2 } })\n        })\n      } else if (point.curve.type === 'quadratic') {\n        const x1 = px + (2 / 3 * (point.curve.x1 - px))\n        const y1 = py + (2 / 3 * (point.curve.y1 - py))\n        const x2 = cx + (2 / 3 * (point.curve.x1 - cx))\n        const y2 = cy + (2 / 3 * (point.curve.y1 - cy))\n\n        s.push({ x: cx, y: cy, curve: { type: 'cubic', x1, y1, x2, y2 } })\n      }\n    } else {\n      s.push(point)\n    }\n  }\n\n  return s\n}\n\nconst cubify = s => applyFuncToShapes(cubifyShape, s)\n\nexport default cubify\n","import cubify from './cubify'\nimport { numberAtInterval } from './helpers'\n\nconst linearPoints = (from, to) => [\n  {\n    x: numberAtInterval(from.x, to.x, 0.5),\n    y: numberAtInterval(from.y, to.y, 0.5)\n  },\n  to\n]\n\nconst curvedPoints = (from, to) => {\n  const { x1, y1, x2, y2 } = to.curve\n\n  const A = { x: from.x, y: from.y }\n  const B = { x: x1, y: y1 }\n  const C = { x: x2, y: y2 }\n  const D = { x: to.x, y: to.y }\n  const E = { x: numberAtInterval(A.x, B.x, 0.5), y: numberAtInterval(A.y, B.y, 0.5) }\n  const F = { x: numberAtInterval(B.x, C.x, 0.5), y: numberAtInterval(B.y, C.y, 0.5) }\n  const G = { x: numberAtInterval(C.x, D.x, 0.5), y: numberAtInterval(C.y, D.y, 0.5) }\n  const H = { x: numberAtInterval(E.x, F.x, 0.5), y: numberAtInterval(E.y, F.y, 0.5) }\n  const J = { x: numberAtInterval(F.x, G.x, 0.5), y: numberAtInterval(F.y, G.y, 0.5) }\n  const K = { x: numberAtInterval(H.x, J.x, 0.5), y: numberAtInterval(H.y, J.y, 0.5) }\n\n  return [\n    { x: K.x, y: K.y, curve: { type: 'cubic', x1: E.x, y1: E.y, x2: H.x, y2: H.y } },\n    { x: D.x, y: D.y, curve: { type: 'cubic', x1: J.x, y1: J.y, x2: G.x, y2: G.y } }\n  ]\n}\n\nconst points = (from, to) => to.curve\n  ? curvedPoints(from, to)\n  : linearPoints(from, to)\n\nconst addPoints = (shape, pointsRequired) => {\n  if (isNaN(pointsRequired)) {\n    throw Error('`add` function must be passed a number as the second argument')\n  }\n\n  const nextShape = [ ...shape ]\n\n  for (let i = 1; i < nextShape.length;) {\n    if (nextShape.length >= pointsRequired) {\n      return nextShape\n    }\n\n    const to = nextShape[ i ]\n\n    if (to.moveTo) {\n      i++\n    } else {\n      const from = nextShape[ i - 1 ]\n      const [ midPoint, replacementPoint ] = points(from, to)\n\n      nextShape.splice(i, 1, midPoint, replacementPoint)\n\n      i += 2\n    }\n  }\n\n  return addPoints(nextShape, pointsRequired)\n}\n\nconst add = (shape, pointsRequired) => addPoints(cubify(shape), pointsRequired)\n\nexport { curvedPoints }\nexport default add\n","import decurve from './decurve'\n\nconst length = (shape, accuracy) => {\n  const s = decurve(shape, accuracy)\n\n  return s.reduce((currentLength, { x: x2, y: y2, moveTo }, i) => {\n    if (!moveTo) {\n      const { x: x1, y: y1 } = s[ i - 1 ]\n      currentLength += linearLength(x1, y1, x2, y2)\n    }\n\n    return currentLength\n  }, 0)\n}\n\nconst linearLength = (x1, y1, x2, y2) => Math.sqrt(\n  Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2)\n)\n\nexport { linearLength }\nexport default length\n","import { angleFromSides } from './helpers'\nimport cubify from './cubify'\nimport { curvedPoints } from './add'\nimport { linearLength } from './length'\n\nconst angle = triangle => {\n  const [ ax, ay ] = triangle[ 0 ]\n  const [ bx, by ] = triangle[ 1 ]\n  const [ cx, cy ] = triangle[ 2 ]\n\n  const a = linearLength(ax, ay, bx, by)\n  const b = linearLength(bx, by, cx, cy)\n  const c = linearLength(cx, cy, ax, ay)\n\n  return angleFromSides(a, b, c)\n}\n\nconst curved = shape => shape.reduce((c, { curve }) => curve ? true : c, false)\n\nconst decurve = (shape, accuracy = 1) => {\n  if (!curved(shape)) {\n    return shape\n  }\n\n  const s = cubify(shape)\n  const d = []\n\n  s.map((point, i) => {\n    if (point.curve) {\n      const prevPoint = s[ i - 1 ]\n      straighten(prevPoint, point, accuracy)\n        .map(p => d.push(p))\n    } else {\n      d.push(point)\n    }\n  })\n\n  return d\n}\n\nconst straight = (x1, y1, cx1, cy1, x2, y2, cx2, cy2, accuracy) => {\n  const t1 = [[ cx1, cy1 ], [ x2, y2 ], [ x1, y1 ]]\n  const t2 = [[ cx2, cy2 ], [ x1, y1 ], [ x2, y2 ]]\n  return angle(t1) < accuracy && angle(t2) < accuracy\n}\n\nconst straighten = (prevPoint, point, accuracy) => {\n  const { x: x1, y: y1 } = prevPoint\n  const { x: x2, y: y2, curve } = point\n  const { x1: cx1, y1: cy1, x2: cx2, y2: cy2 } = curve\n\n  if (straight(x1, y1, cx1, cy1, x2, y2, cx2, cy2, accuracy)) {\n    return [ point ]\n  }\n\n  const [ midPoint, lastPoint ] = curvedPoints(prevPoint, point)\n\n  return [\n    ...straighten(prevPoint, midPoint, accuracy),\n    ...straighten(midPoint, lastPoint, accuracy)\n  ]\n}\n\nexport default decurve\n","import decurve from './decurve'\nimport { getShapeArray } from './helpers'\n\nconst boundingBox = s => {\n  let bottom\n  let left\n  let right\n  let top\n\n  const shapes = getShapeArray(s)\n\n  shapes.map(shape => decurve(shape).map(({ x, y }) => {\n    if (typeof bottom !== 'number' || y > bottom) {\n      bottom = y\n    }\n\n    if (typeof left !== 'number' || x < left) {\n      left = x\n    }\n\n    if (typeof right !== 'number' || x > right) {\n      right = x\n    }\n\n    if (typeof top !== 'number' || y < top) {\n      top = y\n    }\n  }))\n\n  return {\n    bottom,\n    center: {\n      x: left + ((right - left) / 2),\n      y: top + ((bottom - top) / 2)\n    },\n    left,\n    right,\n    top\n  }\n}\n\nexport default boundingBox\n","const countLinePoints = lines => lines.reduce((count, points) => (\n  count + countPoints(points)\n), 0)\n\nconst countPoints = points => points.length - (isJoined(points) ? 1 : 0)\n\nconst isJoined = points => {\n  const firstPoint = points[ 0 ]\n  const lastPoint = points[ points.length - 1 ]\n  return firstPoint.x === lastPoint.x && firstPoint.y === lastPoint.y\n}\n\nconst joinLines = lines => lines.reduce((shape, line) => (\n  [ ...shape, ...line ]\n), [])\n\nconst moveIndex = (shape, offset) => {\n  const lines = splitLines(shape)\n  const count = countLinePoints(lines)\n  const normalisedOffset = ((offset % count) + count) % count\n\n  if (!normalisedOffset) {\n    return shape\n  }\n\n  const { lineIndex, pointIndex } = nextIndex(lines, normalisedOffset)\n  const reorderedLines = reorderLines(lines, lineIndex)\n  const firstLine = reorderPoints(reorderedLines[ 0 ], pointIndex)\n  const restOfLines = [ ...reorderedLines ].splice(1)\n\n  return joinLines([ firstLine, ...restOfLines ])\n}\n\nconst nextIndex = (lines, offset) => {\n  for (let i = 0, l = lines.length; i < l; i++) {\n    const count = countPoints(lines[ i ])\n\n    if (offset <= count - 1) {\n      return {\n        lineIndex: i,\n        pointIndex: offset\n      }\n    }\n\n    offset -= count\n  }\n}\n\nconst reorderLines = (lines, offset) => [ ...lines ]\n  .splice(offset)\n  .concat([ ...lines ].splice(0, offset))\n\nconst reorderPoints = (points, offset) => {\n  if (!offset) {\n    return points\n  }\n\n  const nextPoints = [\n    { x: points[ offset ].x, y: points[ offset ].y, moveTo: true },\n    ...[ ...points ].splice(offset + 1)\n  ]\n\n  if (isJoined(points)) {\n    return [\n      ...nextPoints,\n      ...[ ...points ].splice(1, offset)\n    ]\n  }\n\n  return [\n    ...nextPoints,\n    ...[ ...points ].splice(0, offset + 1)\n  ]\n}\n\nconst splitLines = shape => shape.reduce((lines, point) => {\n  if (point.moveTo) {\n    lines.push([])\n  }\n\n  lines[ lines.length - 1 ].push(point)\n\n  return lines\n}, [])\n\nexport default moveIndex\n","import { applyFuncToShapes } from './helpers'\n\nconst offsetPoints = (shape, x, y) => shape.map(point => {\n  const p = { ...point }\n\n  p.x += x\n  p.y += y\n\n  if (p.curve) {\n    p.curve = { ...p.curve }\n\n    if (p.curve.type === 'quadratic' || p.curve.type === 'cubic') {\n      p.curve.x1 += x\n      p.curve.y1 += y\n    }\n\n    if (p.curve.type === 'cubic') {\n      p.curve.x2 += x\n      p.curve.y2 += y\n    }\n  }\n\n  return p\n})\n\nconst offset = (s, x = 0, y = 0) => applyFuncToShapes(offsetPoints, s, x, y)\n\nexport default offset\n","import decurve from './decurve'\nimport length, { linearLength } from './length'\nimport { angleFromSides, numberAtInterval } from './helpers'\n\nconst angle = (x1, y1, x2, y2, a) => {\n  if (x1 === x2) {\n    return y1 >= y2 ? 0 : 180\n  }\n\n  const b = 100\n  const c = linearLength(x2, y2, x1, y1 - b)\n  const ang = angleFromSides(a, b, c)\n\n  return x1 < x2 ? ang : 360 - ang\n}\n\nconst over = (shape, length, totalLength, desiredLength) => {\n  const { x: x1, y: y1 } = shape[ length - 2 ]\n  const { x: x2, y: y2 } = shape[ length - 1 ]\n  const segmentLength = linearLength(x1, y1, x2, y2)\n  const segmentInterval = (desiredLength - totalLength) / segmentLength + 1\n  return { x1, y1, x2, y2, segmentInterval, segmentLength }\n}\n\nconst position = (shape, interval, accuracy) => {\n  const s = decurve(shape, accuracy)\n  const l = s.length\n  const t = length(s)\n  const d = t * interval\n\n  const { x1, y1, x2, y2, segmentInterval, segmentLength } =\n    interval > 1 ? over(s, l, t, d)\n      : (interval < 0 ? under(s, d) : within(s, l, d))\n\n  return {\n    angle: angle(x1, y1, x2, y2, segmentLength),\n    x: numberAtInterval(x1, x2, segmentInterval),\n    y: numberAtInterval(y1, y2, segmentInterval)\n  }\n}\n\nconst under = (shape, desiredLength) => {\n  const { x: x1, y: y1 } = shape[ 0 ]\n  const { x: x2, y: y2 } = shape[ 1 ]\n  const segmentLength = linearLength(x1, y1, x2, y2)\n  const segmentInterval = desiredLength / segmentLength\n  return { x1, y1, x2, y2, segmentInterval, segmentLength }\n}\n\nconst within = (shape, length, desiredLength) => {\n  let currentLength = 0\n\n  for (let i = 0; i < length; i++) {\n    const { moveTo } = shape[ i ]\n\n    if (!moveTo) {\n      const { x: x1, y: y1 } = shape[ i - 1 ]\n      const { x: x2, y: y2 } = shape[ i ]\n\n      const segmentLength = linearLength(x1, y1, x2, y2)\n\n      if (currentLength + segmentLength >= desiredLength) {\n        const segmentInterval = (desiredLength - currentLength) / segmentLength\n        return { x1, y1, x2, y2, segmentInterval, segmentLength }\n      }\n\n      currentLength += segmentLength\n    }\n  }\n}\n\nexport default position\n","import { applyFuncToShapes } from './helpers'\n\nconst isBetween = (a, b, c) => {\n  if (b.curve || c.curve) {\n    return false\n  }\n\n  const crossProduct =\n    (c.y - a.y) *\n    (b.x - a.x) -\n    (c.x - a.x) *\n    (b.y - a.y)\n\n  if (Math.abs(crossProduct) > Number.EPSILON) {\n    return false\n  }\n\n  const dotProduct =\n    (c.x - a.x) *\n    (b.x - a.x) +\n    (c.y - a.y) *\n    (b.y - a.y)\n\n  if (dotProduct < 0) {\n    return false\n  }\n\n  const squaredLengthBA =\n    (b.x - a.x) *\n    (b.x - a.x) +\n    (b.y - a.y) *\n    (b.y - a.y)\n\n  if (dotProduct > squaredLengthBA) {\n    return false\n  }\n\n  return true\n}\n\nconst removePoints = shape => {\n  const s = []\n\n  for (let i = 0, l = shape.length; i < l; i++) {\n    const a = s[ s.length - 1 ]\n    const b = shape[ i + 1 ]\n    const c = shape[ i ]\n\n    if (!(a && b && c) || !(isBetween(a, b, c))) {\n      s.push(c)\n    }\n  }\n\n  return s\n}\n\nconst remove = s => applyFuncToShapes(removePoints, s)\n\nexport default remove\n","import cubify from './cubify'\nimport { applyFuncToShapes } from './helpers'\n\nconst reversePoints = shape => {\n  let m\n  let c\n\n  return shape.reverse().map(({ x, y, moveTo, curve }, i) => {\n    const point = { x, y }\n\n    if (c) {\n      const { x1: x2, y1: y2, x2: x1, y2: y1 } = c\n      point.curve = { type: 'cubic', x1, y1, x2, y2 }\n    }\n\n    if (i === 0 || m) {\n      point.moveTo = true\n    }\n\n    m = moveTo\n    c = curve || null\n\n    return point\n  })\n}\n\nconst reverse = s => applyFuncToShapes(reversePoints, cubify(s))\n\nexport default reverse\n","import { applyFuncToShapes } from './helpers'\nimport boundingBox from './boundingBox'\n\nconst rotatePoint = (x, y, c, s, about) => {\n  const { x: offsetX, y: offsetY } = about\n  const relativeX = x - offsetX\n  const relativeY = y - offsetY\n\n  return [\n    (relativeX * c - relativeY * s) + offsetX,\n    (relativeX * s + relativeY * c) + offsetY\n  ]\n}\n\nconst rotatePoints = (shape, angle, about) => shape.map(point => {\n  const r = angle * Math.PI / 180\n  const c = Math.cos(r)\n  const s = Math.sin(r)\n  const [ x, y ] = rotatePoint(point.x, point.y, c, s, about)\n  const p = { ...point, x, y }\n\n  if (p.curve) {\n    if (p.curve.type === 'quadratic' || p.curve.type === 'cubic') {\n      const [ x1, y1 ] = rotatePoint(p.curve.x1, p.curve.y1, c, s, about)\n      p.curve = { ...p.curve, x1, y1 }\n    }\n\n    if (p.curve.type === 'cubic') {\n      const [ x2, y2 ] = rotatePoint(p.curve.x2, p.curve.y2, c, s, about)\n      p.curve = { ...p.curve, x2, y2 }\n    }\n  }\n\n  return p\n})\n\nconst rotate = (s, angle) => {\n  const { center: about } = boundingBox(s)\n  return applyFuncToShapes(rotatePoints, s, angle, about)\n}\n\nexport default rotate\n","import boundingBox from './boundingBox'\nimport { applyFuncToShapes } from './helpers'\n\nconst scalePoint = (point, scaleFactor, anchorX, anchorY) => {\n  const p = { ...point }\n\n  p.x = anchorX - ((anchorX - p.x) * scaleFactor)\n  p.y = anchorY - ((anchorY - p.y) * scaleFactor)\n\n  if (point.curve) {\n    p.curve = { ...p.curve }\n\n    if (p.curve.type === 'arc') {\n      if (p.curve.rx) {\n        p.curve.rx = p.curve.rx * scaleFactor\n      }\n\n      if (p.curve.ry) {\n        p.curve.ry = p.curve.ry * scaleFactor\n      }\n    } else {\n      p.curve.x1 = anchorX - ((anchorX - p.curve.x1) * scaleFactor)\n      p.curve.y1 = anchorY - ((anchorY - p.curve.y1) * scaleFactor)\n\n      if (p.curve.type === 'cubic') {\n        p.curve.x2 = anchorX - ((anchorX - p.curve.x2) * scaleFactor)\n        p.curve.y2 = anchorY - ((anchorY - p.curve.y2) * scaleFactor)\n      }\n    }\n  }\n\n  return p\n}\n\nconst scale = (s, scaleFactor, anchor = 'center') => {\n  const { bottom, center, left, right, top } = boundingBox(s)\n\n  let anchorX = center.x\n  let anchorY = center.y\n\n  switch (anchor) {\n    case 'topLeft':\n      anchorX = left\n      anchorY = top\n      break\n    case 'topRight':\n      anchorX = right\n      anchorY = top\n      break\n    case 'bottomRight':\n      anchorX = right\n      anchorY = bottom\n      break\n    case 'bottomLeft':\n      anchorX = left\n      anchorY = bottom\n      break\n  }\n\n  return applyFuncToShapes(shape => shape.map(point => {\n    return scalePoint(point, scaleFactor, anchorX, anchorY)\n  }), s)\n}\n\nexport default scale\n"],"names":["TAU","Math","PI","mapToEllipse","rx","ry","cosphi","sinphi","centerx","centery","x","y","approxUnitArc","ang1","ang2","a","tan","x1","cos","y1","sin","x2","y2","vectorAngle","ux","uy","vx","vy","sign","div","sqrt","acos","getArcCenter","px","py","cx","cy","largeArcFlag","sweepFlag","pxp","pyp","rxsq","pow","rysq","pxpsq","pypsq","radicant","centerxp","centeryp","vx1","vy1","vx2","vy2","arcToBezier","xAxisRotation","curves","abs","lambda","segments","max","ceil","i","push","map","curve","angleFromSides","b","c","applyFuncToShapes","f","s","args","isShapeArray","shape","getShapeArray","Array","isArray","numberAtInterval","interval","cubifyShape","l","length","point","type","forEach","cubify","linearPoints","from","to","curvedPoints","A","B","C","D","E","F","G","H","J","K","points","addPoints","pointsRequired","isNaN","Error","nextShape","moveTo","midPoint","replacementPoint","splice","accuracy","decurve","reduce","currentLength","linearLength","angle","triangle","ax","ay","bx","by","curved","d","prevPoint","p","straight","cx1","cy1","cx2","cy2","t2","straighten","lastPoint","boundingBox","bottom","left","right","top","countLinePoints","lines","count","countPoints","isJoined","firstPoint","joinLines","line","nextIndex","offset","reorderLines","concat","reorderPoints","nextPoints","splitLines","offsetPoints","ang","over","totalLength","desiredLength","segmentLength","segmentInterval","under","within","isBetween","crossProduct","Number","EPSILON","dotProduct","removePoints","reversePoints","m","reverse","rotatePoint","about","offsetX","offsetY","relativeX","relativeY","rotatePoints","r","scalePoint","scaleFactor","anchorX","anchorY","normalisedOffset","lineIndex","pointIndex","reorderedLines","firstLine","restOfLines","t","center","anchor"],"mappings":"g4BASMA,EAAgB,EAAVC,KAAKC,GAEXC,EAAe,WAAWC,EAAIC,EAAIC,EAAQC,EAAQC,EAASC,OAAzCC,IAAAA,EAAGC,IAAAA,WAIdL,MAHNF,GAGmBG,MAFnBF,GAMKG,IAHCD,EAASG,EAAIJ,EAASK,EAIvBF,IAING,EAAgB,SAACC,EAAMC,OACrBC,EAAI,EAAI,EAAId,KAAKe,IAAIF,EAAO,GAE5BG,EAAKhB,KAAKiB,IAAIL,GACdM,EAAKlB,KAAKmB,IAAIP,GACdQ,EAAKpB,KAAKiB,IAAIL,EAAOC,GACrBQ,EAAKrB,KAAKmB,IAAIP,EAAOC,aAIpBG,EAAKE,EAAKJ,IACVI,EAAKF,EAAKF,MAGVM,EAAKC,EAAKP,IACVO,EAAKD,EAAKN,MAGVM,IACAC,KAKHC,EAAc,SAACC,EAAIC,EAAIC,EAAIC,OACzBC,EAAQJ,EAAKG,EAAKF,EAAKC,EAAK,GAAM,EAAI,EAKxCG,GAFQL,EAAKE,EAAKD,EAAKE,IAFd1B,KAAK6B,KAAKN,EAAKA,EAAKC,EAAKA,GACzBxB,KAAK6B,KAAKN,EAAKA,EAAKC,EAAKA,WAKlCI,EAAM,MACF,GAGJA,GAAO,OACF,GAGFD,EAAO3B,KAAK8B,KAAKF,IAGpBG,EAAe,SACnBC,EACAC,EACAC,EACAC,EACAhC,EACAC,EACAgC,EACAC,EACA/B,EACAD,EACAiC,EACAC,OAEMC,EAAOxC,KAAKyC,IAAItC,EAAI,GACpBuC,EAAO1C,KAAKyC,IAAIrC,EAAI,GACpBuC,EAAQ3C,KAAKyC,IAAIH,EAAK,GACtBM,EAAQ5C,KAAKyC,IAAIF,EAAK,GAExBM,EAAYL,EAAOE,EAASF,EAAOI,EAAUF,EAAOC,EAEpDE,EAAW,MACF,MAGAL,EAAOI,EAAUF,EAAOC,MAG/BG,KAFK9C,KAAK6B,KAAKgB,IAAaT,IAAiBC,GAAa,EAAI,IAExClC,EAAKC,EAAKmC,EAChCQ,EAAWF,GAAYzC,EAAKD,EAAKmC,EAEjC/B,EAAUF,EAASyC,EAAWxC,EAASyC,GAAYf,EAAKE,GAAM,EAC9D1B,EAAUF,EAASwC,EAAWzC,EAAS0C,GAAYd,EAAKE,GAAM,EAE9Da,GAAOV,EAAMQ,GAAY3C,EACzB8C,GAAOV,EAAMQ,GAAY3C,EACzB8C,IAAQZ,EAAMQ,GAAY3C,EAC1BgD,IAAQZ,EAAMQ,GAAY3C,EAE5BQ,EAAOU,EAAY,EAAG,EAAG0B,EAAKC,GAC9BpC,EAAOS,EAAY0B,EAAKC,EAAKC,EAAKC,UAEpB,IAAdd,GAAmBxB,EAAO,OACpBd,GAGQ,IAAdsC,GAAmBxB,EAAO,OACpBd,IAGDQ,EAASC,EAASI,EAAMC,IAG7BuC,EAAc,gBAClBpB,IAAAA,GACAC,IAAAA,GACAC,IAAAA,GACAC,IAAAA,GACAhC,IAAAA,GACAC,IAAAA,OACAiD,cAAAA,aAAgB,QAChBjB,aAAAA,aAAe,QACfC,UAAAA,aAAY,IAENiB,QAEK,IAAPnD,GAAmB,IAAPC,eAIVE,EAASN,KAAKmB,IAAIkC,EAAgBtD,EAAM,KACxCM,EAASL,KAAKiB,IAAIoC,EAAgBtD,EAAM,KAExCuC,EAAMjC,GAAU2B,EAAKE,GAAM,EAAI5B,GAAU2B,EAAKE,GAAM,EACpDI,GAAOjC,GAAU0B,EAAKE,GAAM,EAAI7B,GAAU4B,EAAKE,GAAM,KAE/C,IAARG,GAAqB,IAARC,aAIZvC,KAAKuD,IAAIpD,KACTH,KAAKuD,IAAInD,OAERoD,EACJxD,KAAKyC,IAAIH,EAAK,GAAKtC,KAAKyC,IAAItC,EAAI,GAChCH,KAAKyC,IAAIF,EAAK,GAAKvC,KAAKyC,IAAIrC,EAAI,GAE9BoD,EAAS,OACLxD,KAAK6B,KAAK2B,MACVxD,KAAK6B,KAAK2B,UAGqBzB,EACrCC,EACAC,EACAC,EACAC,EACAhC,EACAC,EACAgC,EACAC,EACA/B,EACAD,EACAiC,EACAC,YAZIhC,OAASC,OAASI,OAAMC,OAexB4C,EAAWzD,KAAK0D,IAAI1D,KAAK2D,KAAK3D,KAAKuD,IAAI1C,IAASd,EAAM,IAAK,MAEzD0D,MAEH,IAAIG,EAAI,EAAGA,EAAIH,EAAUG,MACrBC,KAAKlD,EAAcC,EAAMC,OACxBA,SAGHyC,EAAOQ,IAAI,kBACS5D,EAAa6D,EAAO,GAAK5D,EAAIC,EAAIC,EAAQC,EAAQC,EAASC,GAAxEQ,IAAHP,EAAUS,IAAHR,IACUR,EAAa6D,EAAO,GAAK5D,EAAIC,EAAIC,EAAQC,EAAQC,EAASC,GAAxEY,IAAHX,EAAUY,IAAHX,IACER,EAAa6D,EAAO,GAAK5D,EAAIC,EAAIC,EAAQC,EAAQC,EAASC,UAElEQ,KAAIE,KAAIE,KAAIC,KAAIZ,IAFjBA,EAEoBC,IAFjBA,MC1LTsD,EAAiB,SAAClD,EAAGmD,EAAGC,UAClBlE,KAAK8B,MACZ9B,KAAKyC,IAAI3B,EAAG,GAAKd,KAAKyC,IAAIwB,EAAG,GAAKjE,KAAKyC,IAAIyB,EAAG,KAC9C,EAAIpD,EAAImD,KAGC,IAAMjE,KAAKC,KAGnBkE,EAAoB,SAACC,EAAGC,8BAAMC,0DAC9BC,EAAaF,GACRA,EAAEP,IAAI,mBAASM,gBAAEI,UAAUF,MAG7BF,gBAAEC,UAAMC,KAGXG,EAAgB,mBAAKF,EAAaF,GAAKA,GAAMA,IAE7CE,EAAe,mBAAKG,MAAMC,QAAQN,EAAG,KAErCO,EAAmB,SAAC9D,EAAGmD,EAAGY,OACxBX,EAAIpD,IAAMmD,EAAI,EAAIjE,KAAKuD,IAAIU,EAAInD,UACxB,IAANoD,EAAUpD,EAAKA,EAAImD,EAAInD,EAAIoD,EAAIW,EAAW/D,EAAIoD,EAAIW,GCpBrDC,EAAc,gBAGb,IAFCT,KAEGT,EAAI,EAAGmB,EAAIP,EAAMQ,OAAQpB,EAAImB,EAAGnB,IAAK,KACtCqB,EAAQT,EAAOZ,MAEjBqB,EAAMlB,OAA8B,UAArBkB,EAAMlB,MAAMmB,KAAkB,OACtBV,EAAOZ,EAAI,GAAzB5B,IAAHvB,EAAUwB,IAAHvB,EACJwB,EAAc+C,EAAjBxE,EAAU0B,EAAO8C,EAAVvE,KAEU,QAArBuE,EAAMlB,MAAMmB,KACC9B,0BAKT6B,EAAMlB,MAAM5D,MACZ8E,EAAMlB,MAAM3D,iBACD6E,EAAMlB,MAAMV,2BACb4B,EAAMlB,MAAM3B,uBACf6C,EAAMlB,MAAM1B,YAGlB8C,QAAQ,gBAAGnE,IAAAA,GAAIE,IAAAA,GAAIE,IAAAA,GAAIC,IAAAA,GAAIZ,IAAAA,EAAGC,IAAAA,IACjCmD,MAAOpD,IAAGC,IAAGqD,OAASmB,KAAM,QAASlE,KAAIE,KAAIE,KAAIC,eAEhD,GAAyB,cAArB4D,EAAMlB,MAAMmB,KAAsB,KACrClE,EAAKgB,EAAM,EAAI,GAAKiD,EAAMlB,MAAM/C,GAAKgB,GACrCd,EAAKe,EAAM,EAAI,GAAKgD,EAAMlB,MAAM7C,GAAKe,GACrCb,EAAKc,EAAM,EAAI,GAAK+C,EAAMlB,MAAM/C,GAAKkB,GACrCb,EAAKc,EAAM,EAAI,GAAK8C,EAAMlB,MAAM7C,GAAKiB,KAEzC0B,MAAOpD,EAAGyB,EAAIxB,EAAGyB,EAAI4B,OAASmB,KAAM,QAASlE,KAAIE,KAAIE,KAAIC,gBAG3DwC,KAAKoB,UAIJZ,GAGHe,EAAS,mBAAKjB,EAAkBW,EAAaT,IC1C7CgB,EAAe,SAACC,EAAMC,aAErBX,EAAiBU,EAAK7E,EAAG8E,EAAG9E,EAAG,MAC/BmE,EAAiBU,EAAK5E,EAAG6E,EAAG7E,EAAG,KAEpC6E,IAGIC,EAAe,SAACF,EAAMC,SACCA,EAAGxB,MAAtB/C,IAAAA,GAAIE,IAAAA,GAAIE,IAAAA,GAAIC,IAAAA,GAEdoE,GAAMhF,EAAG6E,EAAK7E,EAAGC,EAAG4E,EAAK5E,GACzBgF,GAAMjF,EAAGO,EAAIN,EAAGQ,GAChByE,GAAMlF,EAAGW,EAAIV,EAAGW,GAChBuE,GAAMnF,EAAG8E,EAAG9E,EAAGC,EAAG6E,EAAG7E,GACrBmF,GAAMpF,EAAGmE,EAAiBa,EAAEhF,EAAGiF,EAAEjF,EAAG,IAAMC,EAAGkE,EAAiBa,EAAE/E,EAAGgF,EAAEhF,EAAG,KACxEoF,GAAMrF,EAAGmE,EAAiBc,EAAEjF,EAAGkF,EAAElF,EAAG,IAAMC,EAAGkE,EAAiBc,EAAEhF,EAAGiF,EAAEjF,EAAG,KACxEqF,GAAMtF,EAAGmE,EAAiBe,EAAElF,EAAGmF,EAAEnF,EAAG,IAAMC,EAAGkE,EAAiBe,EAAEjF,EAAGkF,EAAElF,EAAG,KACxEsF,GAAMvF,EAAGmE,EAAiBiB,EAAEpF,EAAGqF,EAAErF,EAAG,IAAMC,EAAGkE,EAAiBiB,EAAEnF,EAAGoF,EAAEpF,EAAG,KACxEuF,GAAMxF,EAAGmE,EAAiBkB,EAAErF,EAAGsF,EAAEtF,EAAG,IAAMC,EAAGkE,EAAiBkB,EAAEpF,EAAGqF,EAAErF,EAAG,KACxEwF,GAAMzF,EAAGmE,EAAiBoB,EAAEvF,EAAGwF,EAAExF,EAAG,IAAMC,EAAGkE,EAAiBoB,EAAEtF,EAAGuF,EAAEvF,EAAG,aAG1ED,EAAGyF,EAAEzF,EAAGC,EAAGwF,EAAExF,EAAGqD,OAASmB,KAAM,QAASlE,GAAI6E,EAAEpF,EAAGS,GAAI2E,EAAEnF,EAAGU,GAAI4E,EAAEvF,EAAGY,GAAI2E,EAAEtF,KACzED,EAAGmF,EAAEnF,EAAGC,EAAGkF,EAAElF,EAAGqD,OAASmB,KAAM,QAASlE,GAAIiF,EAAExF,EAAGS,GAAI+E,EAAEvF,EAAGU,GAAI2E,EAAEtF,EAAGY,GAAI0E,EAAErF,MAIzEyF,EAAS,SAACb,EAAMC,UAAOA,EAAGxB,MAC5ByB,EAAaF,EAAMC,GACnBF,EAAaC,EAAMC,IAEjBa,EAAY,SAAZA,EAAa5B,EAAO6B,MACpBC,MAAMD,SACFE,MAAM,qEAKT,IAFCC,cAAiBhC,IAEdZ,EAAI,EAAGA,EAAI4C,EAAUxB,QAAS,IACjCwB,EAAUxB,QAAUqB,SACfG,MAGHjB,EAAKiB,EAAW5C,MAElB2B,EAAGkB,eAEA,KACCnB,EAAOkB,EAAW5C,EAAI,KACWuC,EAAOb,EAAMC,YAA5CmB,OAAUC,SAERC,OAAOhD,EAAG,EAAG8C,EAAUC,MAE5B,UAIFP,EAAUI,EAAWH,IC3DxBrB,EAAS,SAACR,EAAOqC,OACfxC,EAAIyC,EAAQtC,EAAOqC,UAElBxC,EAAE0C,OAAO,SAACC,IAAyCpD,OAArBxC,IAAHX,EAAUY,IAAHX,QAAO+F,OACjC,OACcpC,EAAGT,EAAI,GAArB5C,IAAHP,EAAUS,IAAHR,KACEuG,EAAajG,EAAIE,EAAIE,EAAIC,UAGrC2F,GACN,IAGCC,EAAe,SAACjG,EAAIE,EAAIE,EAAIC,UAAOrB,KAAK6B,KAC5C7B,KAAKyC,IAAIzB,EAAKI,EAAI,GAAKpB,KAAKyC,IAAIvB,EAAKG,EAAI,KCXrC6F,EAAQ,oBACOC,EAAU,MAArBC,OAAIC,WACOF,EAAU,MAArBG,OAAIC,WACOJ,EAAU,MAArBjF,OAAIC,OAENrB,EAAImG,EAAaG,EAAIC,EAAIC,EAAIC,GAC7BtD,EAAIgD,EAAaK,EAAIC,EAAIrF,EAAIC,GAC7B+B,EAAI+C,EAAa/E,EAAIC,EAAIiF,EAAIC,UAE5BrD,EAAelD,EAAGmD,EAAGC,IAGxBsD,EAAS,mBAAShD,EAAMuC,OAAO,SAAC7C,eAAKH,OAA2BG,IAAG,IAEnE4C,EAAU,SAACtC,OAAOqC,yDAAW,MAC5BW,EAAOhD,UACHA,MAGHH,EAAIe,EAAOZ,GACXiD,cAEJ3D,IAAI,SAACmB,EAAOrB,MACRqB,EAAMlB,MAAO,KACT2D,EAAYrD,EAAGT,EAAI,KACd8D,EAAWzC,EAAO4B,GAC1B/C,IAAI,mBAAK2D,EAAE5D,KAAK8D,YAEjB9D,KAAKoB,KAIJwC,GAGHG,EAAW,SAAC5G,EAAIE,EAAI2G,EAAKC,EAAK1G,EAAIC,EAAI0G,EAAKC,EAAKnB,OAE9CoB,IAAQF,EAAKC,IAAShH,EAAIE,IAAQE,EAAIC,WACrC6F,IAFOW,EAAKC,IAAS1G,EAAIC,IAAQL,EAAIE,KAEzB2F,GAAYK,EAAMe,GAAMpB,GAGvCqB,EAAa,SAAbA,EAAcR,EAAWzC,EAAO4B,OACzB7F,EAAc0G,EAAjBjH,EAAUS,EAAOwG,EAAVhH,EACJU,EAAqB6D,EAAxBxE,EAAUY,EAAc4D,EAAjBvE,EAAOqD,EAAUkB,EAAVlB,MACV8D,EAAmC9D,EAAvC/C,GAAa8G,EAA0B/D,EAA9B7C,GAAa6G,EAAiBhE,EAArB3C,GAAa4G,EAAQjE,EAAZ1C,MAE/BuG,EAAS5G,EAAIE,EAAI2G,EAAKC,EAAK1G,EAAIC,EAAI0G,EAAKC,EAAKnB,UACtC5B,SAGqBO,EAAakC,EAAWzC,YAAhDyB,OAAUyB,yBAGbD,EAAWR,EAAWhB,EAAUG,MAChCqB,EAAWxB,EAAUyB,EAAWtB,MCxDjCuB,EAAc,gBACdC,SACAC,SACAC,SACAC,gBAEW/D,EAAcJ,GAEtBP,IAAI,mBAASgD,EAAQtC,GAAOV,IAAI,gBAAGrD,IAAAA,EAAGC,IAAAA,GACrB,iBAAX2H,GAAuB3H,EAAI2H,OAC3B3H,IAGS,iBAAT4H,GAAqB7H,EAAI6H,OAC3B7H,IAGY,iBAAV8H,GAAsB9H,EAAI8H,OAC3B9H,IAGS,iBAAR+H,GAAoB9H,EAAI8H,OAC3B9H,2BAOH4H,GAASC,EAAQD,GAAQ,IACzBE,GAAQH,EAASG,GAAO,0BCjC3BC,EAAkB,mBAASC,EAAM3B,OAAO,SAAC4B,EAAOxC,UACpDwC,EAAQC,EAAYzC,IACnB,IAEGyC,EAAc,mBAAUzC,EAAOnB,QAAU6D,EAAS1C,GAAU,EAAI,IAEhE0C,EAAW,gBACTC,EAAa3C,EAAQ,GACrBgC,EAAYhC,EAAQA,EAAOnB,OAAS,UACnC8D,EAAWrI,IAAM0H,EAAU1H,GAAKqI,EAAWpI,IAAMyH,EAAUzH,GAG9DqI,EAAY,mBAASL,EAAM3B,OAAO,SAACvC,EAAOwE,qBACzCxE,KAAUwE,UAoBXC,EAAY,SAACP,EAAOQ,OACnB,IAAItF,EAAI,EAAGmB,EAAI2D,EAAM1D,OAAQpB,EAAImB,EAAGnB,IAAK,KACtC+E,EAAQC,EAAYF,EAAO9E,OAE7BsF,GAAUP,EAAQ,mBAEP/E,aACCsF,MAINP,IAIRQ,EAAe,SAACT,EAAOQ,qBAAgBR,IAC1C9B,OAAOsC,GACPE,mBAAYV,IAAQ9B,OAAO,EAAGsC,KAE3BG,EAAgB,SAAClD,EAAQ+C,OACxBA,SACI/C,MAGHmD,IACF7I,EAAG0F,EAAQ+C,GAASzI,EAAGC,EAAGyF,EAAQ+C,GAASxI,EAAG+F,QAAQ,yBAChDN,IAASS,OAAOsC,EAAS,YAG/BL,EAAS1C,eAENmD,iBACKnD,IAASS,OAAO,EAAGsC,iBAK1BI,iBACKnD,IAASS,OAAO,EAAGsC,EAAS,MAIlCK,EAAa,mBAAS/E,EAAMuC,OAAO,SAAC2B,EAAOzD,UAC3CA,EAAMwB,UACF5C,WAGD6E,EAAM1D,OAAS,GAAInB,KAAKoB,GAExByD,QChFHc,EAAe,SAAChF,EAAO/D,EAAGC,UAAM8D,EAAMV,IAAI,gBACxC6D,OAAS1C,YAEbxE,GAAKA,IACLC,GAAKA,EAEHiH,EAAE5D,UACFA,WAAa4D,EAAE5D,OAEI,cAAjB4D,EAAE5D,MAAMmB,MAAyC,UAAjByC,EAAE5D,MAAMmB,SACxCnB,MAAM/C,IAAMP,IACZsD,MAAM7C,IAAMR,GAGK,UAAjBiH,EAAE5D,MAAMmB,SACRnB,MAAM3C,IAAMX,IACZsD,MAAM1C,IAAMX,IAIXiH,KClBHT,EAAQ,SAAClG,EAAIE,EAAIE,EAAIC,EAAIP,MACzBE,IAAOI,SACFF,GAAMG,EAAK,EAAI,QAIlB6C,EAAI+C,EAAa7F,EAAIC,EAAIL,EAAIE,EADzB,KAEJuI,EAAMzF,EAAelD,EAFjB,IAEuBoD,UAE1BlD,EAAKI,EAAKqI,EAAM,IAAMA,GAGzBC,EAAO,SAAClF,EAAOQ,EAAQ2E,EAAaC,SACfpF,EAAOQ,EAAS,GAA9BhE,IAAHP,EAAUS,IAAHR,IACU8D,EAAOQ,EAAS,GAA9B5D,IAAHX,EAAUY,IAAHX,EACTmJ,EAAgB5C,EAAajG,EAAIE,EAAIE,EAAIC,UAEtCL,KAAIE,KAAIE,KAAIC,KAAIyI,iBADAF,EAAgBD,GAAeE,EAAgB,EAC9BA,kBAoBtCE,EAAQ,SAACvF,EAAOoF,SACKpF,EAAO,GAArBxD,IAAHP,EAAUS,IAAHR,IACU8D,EAAO,GAArBpD,IAAHX,EAAUY,IAAHX,EACTmJ,EAAgB5C,EAAajG,EAAIE,EAAIE,EAAIC,UAEtCL,KAAIE,KAAIE,KAAIC,KAAIyI,gBADDF,EAAgBC,EACEA,kBAGtCG,EAAS,SAACxF,EAAOQ,EAAQ4E,OAGxB,IAFD5C,EAAgB,EAEXpD,EAAI,EAAGA,EAAIoB,EAAQpB,QACPY,EAAOZ,GAAlB6C,OAEK,OACcjC,EAAOZ,EAAI,GAAzB5C,IAAHP,EAAUS,IAAHR,IACU8D,EAAOZ,GAArBxC,IAAHX,EAAUY,IAAHX,EAETmJ,EAAgB5C,EAAajG,EAAIE,EAAIE,EAAIC,MAE3C2F,EAAgB6C,GAAiBD,SAE1B5I,KAAIE,KAAIE,KAAIC,KAAIyI,iBADAF,EAAgB5C,GAAiB6C,EAChBA,oBAG3BA,IChEjBI,EAAY,SAACnJ,EAAGmD,EAAGC,MACnBD,EAAEF,OAASG,EAAEH,aACR,MAGHmG,GACHhG,EAAExD,EAAII,EAAEJ,IACRuD,EAAExD,EAAIK,EAAEL,IACRyD,EAAEzD,EAAIK,EAAEL,IACRwD,EAAEvD,EAAII,EAAEJ,MAEPV,KAAKuD,IAAI2G,GAAgBC,OAAOC,eAC3B,MAGHC,GACHnG,EAAEzD,EAAIK,EAAEL,IACRwD,EAAExD,EAAIK,EAAEL,IACRyD,EAAExD,EAAII,EAAEJ,IACRuD,EAAEvD,EAAII,EAAEJ,WAEP2J,EAAa,MAUbA,GALDpG,EAAExD,EAAIK,EAAEL,IACRwD,EAAExD,EAAIK,EAAEL,IACRwD,EAAEvD,EAAII,EAAEJ,IACRuD,EAAEvD,EAAII,EAAEJ,KASP4J,EAAe,gBAGd,IAFCjG,KAEGT,EAAI,EAAGmB,EAAIP,EAAMQ,OAAQpB,EAAImB,EAAGnB,IAAK,KACtC9C,EAAIuD,EAAGA,EAAEW,OAAS,GAClBf,EAAIO,EAAOZ,EAAI,GACfM,EAAIM,EAAOZ,GAEX9C,GAAKmD,GAAKC,GAAQ+F,EAAUnJ,EAAGmD,EAAGC,MACpCL,KAAKK,UAIJG,GClDHkG,EAAgB,gBAChBC,SACAtG,gBAEGM,EAAMiG,UAAU3G,IAAI,WAA0BF,OAAvBnD,IAAAA,EAAGC,IAAAA,EAAG+F,IAAAA,OAAQ1C,IAAAA,MACpCkB,GAAUxE,IAAGC,QAEfwD,EAAG,OACsCA,EAA/B9C,IAAJJ,GAAYK,IAAJH,GAAYF,IAAJI,GAAYF,IAAJG,KAC1B0C,OAAUmB,KAAM,QAASlE,KAAIE,KAAIE,KAAIC,aAGnC,IAANuC,GAAW4G,OACP/D,QAAS,KAGbA,IACA1C,GAAS,KAENkB,KCnBLyF,EAAc,SAACjK,EAAGC,EAAGwD,EAAGG,EAAGsG,OACpBC,EAAwBD,EAA3BlK,EAAeoK,EAAYF,EAAfjK,EACdoK,EAAYrK,EAAImK,EAChBG,EAAYrK,EAAImK,SAGnBC,EAAY5G,EAAI6G,EAAY1G,EAAKuG,EACjCE,EAAYzG,EAAI0G,EAAY7G,EAAK2G,IAIhCG,EAAe,SAACxG,EAAO0C,EAAOyD,UAAUnG,EAAMV,IAAI,gBAChDmH,EAAI/D,EAAQlH,KAAKC,GAAK,IACtBiE,EAAIlE,KAAKiB,IAAIgK,GACb5G,EAAIrE,KAAKmB,IAAI8J,KACFP,EAAYzF,EAAMxE,EAAGwE,EAAMvE,EAAGwD,EAAGG,EAAGsG,YAA7ClK,OAAGC,OACLiH,OAAS1C,GAAOxE,IAAGC,SAErBiH,EAAE5D,MAAO,IACU,cAAjB4D,EAAE5D,MAAMmB,MAAyC,UAAjByC,EAAE5D,MAAMmB,KAAkB,OACzCwF,EAAY/C,EAAE5D,MAAM/C,GAAI2G,EAAE5D,MAAM7C,GAAIgD,EAAGG,EAAGsG,YAArD3J,OAAIE,SACV6C,WAAa4D,EAAE5D,OAAO/C,KAAIE,UAGT,UAAjByG,EAAE5D,MAAMmB,KAAkB,OACTwF,EAAY/C,EAAE5D,MAAM3C,GAAIuG,EAAE5D,MAAM1C,GAAI6C,EAAGG,EAAGsG,YAArDvJ,OAAIC,SACV0C,WAAa4D,EAAE5D,OAAO3C,KAAIC,eAIzBsG,KC9BHuD,EAAa,SAACjG,EAAOkG,EAAaC,EAASC,OACzC1D,OAAS1C,YAEbxE,EAAI2K,GAAYA,EAAUzD,EAAElH,GAAK0K,IACjCzK,EAAI2K,GAAYA,EAAU1D,EAAEjH,GAAKyK,EAE/BlG,EAAMlB,UACNA,WAAa4D,EAAE5D,OAEI,QAAjB4D,EAAE5D,MAAMmB,MACNyC,EAAE5D,MAAM5D,OACR4D,MAAM5D,GAAKwH,EAAE5D,MAAM5D,GAAKgL,GAGxBxD,EAAE5D,MAAM3D,OACR2D,MAAM3D,GAAKuH,EAAE5D,MAAM3D,GAAK+K,OAG1BpH,MAAM/C,GAAKoK,GAAYA,EAAUzD,EAAE5D,MAAM/C,IAAMmK,IAC/CpH,MAAM7C,GAAKmK,GAAYA,EAAU1D,EAAE5D,MAAM7C,IAAMiK,EAE5B,UAAjBxD,EAAE5D,MAAMmB,SACRnB,MAAM3C,GAAKgK,GAAYA,EAAUzD,EAAE5D,MAAM3C,IAAM+J,IAC/CpH,MAAM1C,GAAKgK,GAAYA,EAAU1D,EAAE5D,MAAM1C,IAAM8J,KAKhDxD,SViCG,SAACnD,EAAO6B,UAAmBD,EAAUhB,EAAOZ,GAAQ6B,sDIhD9C,SAAC7B,EAAO0E,OAClBR,EAAQa,EAAW/E,GACnBmE,EAAQF,EAAgBC,GACxB4C,GAAqBpC,EAASP,EAASA,GAASA,MAEjD2C,SACI9G,QAGyByE,EAAUP,EAAO4C,GAA3CC,IAAAA,UAAWC,IAAAA,WACbC,EAAiBtC,EAAaT,EAAO6C,GACrCG,EAAYrC,EAAcoC,EAAgB,GAAKD,GAC/CG,cAAmBF,IAAiB7E,OAAO,UAE1CmC,GAAY2C,YAAcC,eCLpB,SAACtH,OAAG5D,yDAAI,EAAGC,yDAAI,SAAMyD,EAAkBqF,EAAcnF,EAAG5D,EAAGC,eCDzD,SAAC8D,EAAOK,EAAUgC,OAC3BxC,EAAIyC,EAAQtC,EAAOqC,GACnB9B,EAAIV,EAAEW,OACN4G,EAAI5G,EAAOX,GACXoD,EAAImE,EAAI/G,IAGZA,EAAW,EAAI6E,EAAKrF,EAAGU,EAAG6G,EAAGnE,GACxB5C,EAAW,EAAIkF,EAAM1F,EAAGoD,GAAKuC,EAAO3F,EAAGU,EAAG0C,GAFzCzG,IAAAA,GAAIE,IAAAA,GAAIE,IAAAA,GAAIC,IAAAA,GAAIyI,IAAAA,gBAAiBD,IAAAA,2BAKhC3C,EAAMlG,EAAIE,EAAIE,EAAIC,EAAIwI,KAC1BjF,EAAiB5D,EAAII,EAAI0I,KACzBlF,EAAiB1D,EAAIG,EAAIyI,cCmBjB,mBAAK3F,EAAkBmG,EAAcjG,cC9BpC,mBAAKF,EAAkBoG,EAAenF,EAAOf,cCU9C,SAACA,EAAG6C,OACDyD,EAAUvC,EAAY/D,GAA9BwH,cACD1H,EAAkB6G,EAAc3G,EAAG6C,EAAOyD,YCJrC,SAACtG,EAAG8G,OAAaW,yDAAS,WACO1D,EAAY/D,GAAjDgE,IAAAA,OAAQwD,IAAAA,OAAQvD,IAAAA,KAAMC,IAAAA,MAAOC,IAAAA,IAEjC4C,EAAUS,EAAOpL,EACjB4K,EAAUQ,EAAOnL,SAEboL,OACD,YACOxD,IACAE,YAEP,aACOD,IACAC,YAEP,gBACOD,IACAF,YAEP,eACOC,IACAD,SAIPlE,EAAkB,mBAASK,EAAMV,IAAI,mBACnCoH,EAAWjG,EAAOkG,EAAaC,EAASC,MAC7ChH"}